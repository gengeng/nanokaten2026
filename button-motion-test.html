<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ボタンテキスト切り替えモーション検証</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'SF Pro Text', 'SF Pro Display', 'Noto Sans JP', system-ui, sans-serif;
  background: #f5f5f5;
  padding: 40px;
  color: #000;
}

h1 { font-size: 20px; margin-bottom: 8px; }
h2 { font-size: 16px; margin-top: 32px; margin-bottom: 12px; color: #666; }

.demo-description {
  font-size: 13px;
  color: #888;
  margin-bottom: 24px;
  line-height: 1.6;
}

/* ========================================
   ボタンコンテナ（本番と同じ構造）
   ======================================== */
.button-stage {
  width: 100%;
  max-width: 800px;
  margin: 0 auto 40px;
}

.action-button-container {
  position: relative;
  width: 100%;
  height: 155px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #000;
  overflow: hidden;
  cursor: pointer;
  border-radius: 8px;
}

.action-button-container.idle {
  background: #000;
}

.action-button-container.generating-state {
  background: #fff;
}

.progress-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: #000;
  width: 0%;
  z-index: 0;
}

.action-button {
  background: transparent;
  border: none;
  color: #FFFFFF;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 20px 40px;
  position: relative;
  z-index: 1;
  pointer-events: none;
  overflow: hidden;
}

.action-button .button-ja,
.action-button .button-en {
  display: block;
  transition: none;
}

.action-button .button-ja {
  font-size: 32px;
  font-weight: 700;
}

.action-button .button-en {
  font-size: 16px;
  font-weight: 700;
}

/* 生成中（styles.cssと同じ: ボタン自体のcolorを変更→子要素に継承） */
.action-button.generating {
  color: rgba(165, 165, 165, 0.6);
}

/* カウントダウン：tabular-numsで数字幅固定 */
.action-button .button-ja .countdown-time,
.action-button .button-en .countdown-time {
  font-variant-numeric: tabular-nums;
  display: inline-block;
  text-align: center;
  min-width: 3.5em;
}

/* ========================================
   テキスト生成プレビュー（ルールリスト模擬 — index.htmlと同じスタイル）
   ======================================== */
.text-preview {
  width: 100%;
  max-width: 800px;
  margin: 0 auto 24px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #fff;
  min-height: 160px;
  max-height: 300px;
  overflow-y: auto;
  padding: 40px;
}
.text-preview .rule-item {
  display: flex;
  gap: 40px;
  align-items: flex-start;
}
.text-preview .rule-number {
  font-size: 32px;
  font-weight: 700;
  color: #999999;
  flex-shrink: 0;
  line-height: 1.5;
  min-width: 96px;
  text-align: left;
}
.text-preview .rule-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  line-height: 1.5;
}
.text-preview .rule-ja {
  font-size: 32px;
  font-weight: 700;
  color: #000000;
}
.text-preview .rule-en {
  font-size: 16px;
  font-weight: 600;
  color: #000000;
}
/* 生成中のグレー表示（styles.cssと同じ） */
.text-preview .rule-ja.generating {
  color: rgba(165, 165, 165, 0.6);
}
.text-preview .rule-en.generating {
  color: rgba(165, 165, 165, 0.6);
}
.text-preview .rule-number.generating {
  color: #999999;
}
.text-preview .caret {
  display: inline-block;
  width: 4px;
  height: 1em;
  background: #000000;
  vertical-align: middle;
  margin-left: 2px;
}
.text-preview .caret.generating {
  background: #000000;
}

/* ========================================
   コントロール
   ======================================== */
.controls {
  max-width: 800px;
  margin: 0 auto;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.control-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.control-row label {
  font-size: 13px;
  min-width: 200px;
  color: #333;
}

.control-row input[type="range"] {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: #ddd;
  border-radius: 2px;
}

.control-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #000;
  border-radius: 50%;
  cursor: pointer;
}

.control-row .val-group {
  display: flex;
  align-items: center;
  gap: 2px;
  min-width: 80px;
  justify-content: flex-end;
}
.control-row .val {
  font-size: 13px;
  font-weight: 600;
  width: 52px;
  text-align: right;
  font-variant-numeric: tabular-nums;
  border: 1px solid transparent;
  background: transparent;
  padding: 2px 4px;
  border-radius: 3px;
  outline: none;
  font-family: inherit;
  -moz-appearance: textfield;
}
.control-row .val:hover {
  border-color: #ccc;
}
.control-row .val:focus {
  border-color: #000;
  background: #fff;
}
.control-row .val::-webkit-inner-spin-button,
.control-row .val::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.control-row .unit {
  font-size: 11px;
  color: #999;
  min-width: 20px;
}

.buttons-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.buttons-row button {
  font-size: 13px;
  padding: 8px 20px;
  border: 1px solid #ccc;
  background: #fff;
  cursor: pointer;
  border-radius: 4px;
  font-weight: 600;
}

.buttons-row button:hover {
  background: #f0f0f0;
}

.buttons-row button.active {
  background: #000;
  color: #fff;
  border-color: #000;
}

/* ========================================
   状態表示
   ======================================== */
.state-indicator {
  max-width: 800px;
  margin: 0 auto 16px;
  font-size: 13px;
  color: #999;
  display: flex;
  gap: 16px;
  align-items: center;
}

.state-indicator .current-state {
  font-weight: 700;
  color: #000;
  font-size: 15px;
}

/* タイムライン表示 */
.timeline-bar {
  max-width: 800px;
  margin: 0 auto 16px;
  height: 24px;
  background: #eee;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
  font-size: 10px;
}
.timeline-bar .tl-phase {
  position: absolute;
  top: 0;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: 600;
  font-size: 10px;
  white-space: nowrap;
  overflow: hidden;
}
.timeline-bar .tl-exit { background: #e74c3c; }
.timeline-bar .tl-drain { background: #333; }
.timeline-bar .tl-gap { background: #f39c12; }
.timeline-bar .tl-enter { background: #3498db; }
.timeline-bar .tl-text-delay { background: #9b59b6; }
.timeline-bar .tl-text { background: #2ecc71; }
</style>
</head>
<body>

<h1>ボタンモーション＋テキスト生成タイミング検証</h1>
<p class="demo-description">
  ボタンを押す → モーション → ドレイン → テキスト生成開始の一連のタイミングを調整。
</p>

<div class="state-indicator">
  <span>状態:</span>
  <span class="current-state" id="current-state">待機中（idle）</span>
</div>

<!-- タイムラインバー -->
<div class="timeline-bar" id="timeline-bar"></div>

<div class="button-stage">
  <div class="action-button-container idle" id="btn-container">
    <div class="progress-fill" id="progress-fill"></div>
    <button class="action-button" id="action-button">
      <span class="button-ja" id="btn-ja">続きを生成</span>
      <span class="button-en" id="btn-en">Continue Generating</span>
    </button>
  </div>
</div>

<!-- テキスト生成プレビュー -->
<div class="text-preview" id="text-preview"></div>

<div class="controls">
  <h2 style="margin:0;">実行フロー</h2>
  <div class="buttons-row">
    <button id="btn-run-flow">▶ フロー実行（ボタン押下→生成→完了）</button>
    <button id="btn-reset">↺ リセット</button>
  </div>

  <h2 style="margin:0;">状態切り替え（個別テスト）</h2>
  <div class="buttons-row" id="state-buttons">
    <button class="active" data-state="idle">待機中 idle</button>
    <button data-state="countdown">カウントダウン countdown</button>
    <button data-state="generating">生成中 generating</button>
    <button data-state="thinking">思考中 thinking</button>
  </div>

  <h2 style="margin:0;">モーションパラメータ</h2>

  <div class="control-row">
    <label>Slide Distance スライド距離:</label>
    <input type="range" id="slider-distance" min="4" max="40" step="1" value="16">
    <span class="val-group"><input class="val" id="val-distance" value="16"><span class="unit">px</span></span>
  </div>

  <div class="control-row">
    <label>Out Duration 退場時間:</label>
    <input type="range" id="slider-out-duration" min="50" max="600" step="10" value="280">
    <span class="val-group"><input class="val" id="val-out-duration" value="280"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>In Duration 登場時間:</label>
    <input type="range" id="slider-in-duration" min="50" max="600" step="10" value="280">
    <span class="val-group"><input class="val" id="val-in-duration" value="280"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Stagger ずらし:</label>
    <input type="range" id="slider-stagger" min="0" max="200" step="5" value="65">
    <span class="val-group"><input class="val" id="val-stagger" value="65"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Gap OUT→IN 退場→登場の間:</label>
    <input type="range" id="slider-gap" min="0" max="300" step="10" value="140">
    <span class="val-group"><input class="val" id="val-gap" value="140"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Out Easing 退場カーブ:</label>
    <select id="select-out-easing" style="flex:1; font-size:13px; padding:4px;">
      <option value="ease-in" selected>ease-in（加速して消える）</option>
      <option value="ease-out">ease-out（減速して消える）</option>
      <option value="ease-in-out">ease-in-out</option>
      <option value="linear">linear</option>
    </select>
  </div>

  <div class="control-row">
    <label>In Easing 登場カーブ:</label>
    <select id="select-in-easing" style="flex:1; font-size:13px; padding:4px;">
      <option value="ease-out" selected>ease-out（減速して現れる）</option>
      <option value="ease-in">ease-in（加速して現れる）</option>
      <option value="ease-in-out">ease-in-out</option>
      <option value="linear">linear</option>
      <option value="back-out">back-out（少しオーバーシュート）</option>
    </select>
  </div>

  <div class="control-row">
    <label>Exit Direction 退場方向:</label>
    <div style="flex:1; display:flex; gap:4px;" id="exit-dir-buttons">
      <button data-dir="up" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">↑ up</button>
      <button data-dir="down" class="active" style="flex:1;padding:6px;font-size:12px;border:1px solid #000;background:#000;color:#fff;cursor:pointer;border-radius:3px;">↓ down</button>
      <button data-dir="left" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">← left</button>
      <button data-dir="right" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">→ right</button>
    </div>
  </div>

  <div class="control-row">
    <label>Enter Direction 登場方向:</label>
    <div style="flex:1; display:flex; gap:4px;" id="enter-dir-buttons">
      <button data-dir="up" class="active" style="flex:1;padding:6px;font-size:12px;border:1px solid #000;background:#000;color:#fff;cursor:pointer;border-radius:3px;">↑ up</button>
      <button data-dir="down" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">↓ down</button>
      <button data-dir="left" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">← left</button>
      <button data-dir="right" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">→ right</button>
    </div>
  </div>

  <div class="control-row">
    <label>Exit Order 退場順序（登場は常にJA先行）:</label>
    <div style="flex:1; display:flex; gap:4px;" id="order-buttons">
      <button data-order="ja-first" style="flex:1;padding:6px;font-size:12px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:3px;">JA先行</button>
      <button data-order="en-first" class="active" style="flex:1;padding:6px;font-size:12px;border:1px solid #000;background:#000;color:#fff;cursor:pointer;border-radius:3px;">EN先行</button>
    </div>
  </div>

  <h2 style="margin:0;">ドレインパラメータ</h2>

  <div class="control-row">
    <label>Drain Duration ドレイン時間:</label>
    <input type="range" id="slider-drain-duration" min="100" max="1500" step="10" value="680">
    <span class="val-group"><input class="val" id="val-drain-duration" value="680"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Drain Easing ドレインカーブ:</label>
    <select id="select-drain-easing" style="flex:1; font-size:13px; padding:4px;">
      <option value="ease-in">ease-in（加速して消える）</option>
      <option value="ease-out">ease-out</option>
      <option value="ease-in-out" selected>ease-in-out</option>
      <option value="linear">linear</option>
    </select>
  </div>
  <p style="font-size:11px;color:#aaa;margin-top:-8px;padding-left:212px;">
    直列実行: EXIT完了 → ドレイン → ENTER の順で実行されます。
  </p>

  <h2 style="margin:0;">テキスト生成</h2>

  <div class="control-row">
    <label>Text Speed テキスト速度:</label>
    <input type="range" id="slider-text-speed" min="10" max="200" step="5" value="40">
    <span class="val-group"><input class="val" id="val-text-speed" value="40"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Generate Duration 生成時間:</label>
    <input type="range" id="slider-gen-duration" min="1000" max="10000" step="500" value="4000">
    <span class="val-group"><input class="val" id="val-gen-duration" value="4000"><span class="unit">ms</span></span>
  </div>

  <h2 style="margin:0;">ゲージパラメータ</h2>

  <div class="control-row">
    <label>Gauge Duration ゲージ時間:</label>
    <input type="range" id="slider-gauge-duration" min="500" max="10000" step="100" value="3000">
    <span class="val-group"><input class="val" id="val-gauge-duration" value="3000"><span class="unit">ms</span></span>
  </div>

  <div class="control-row">
    <label>Gauge Easing ゲージカーブ:</label>
    <select id="select-gauge-easing" style="flex:1; font-size:13px; padding:4px;">
      <option value="linear">linear</option>
      <option value="ease-in">ease-in</option>
      <option value="ease-out" selected>ease-out</option>
      <option value="ease-in-out">ease-in-out</option>
    </select>
  </div>

  <h2 style="margin:0;">自動ループ</h2>
  <div class="buttons-row">
    <button id="btn-auto-loop">▶ 自動ループ開始</button>
  </div>
</div>

<script>
// ========================================
// 状態定義
// ========================================
const STATES = {
  idle: {
    ja: '続きを生成',
    en: 'Continue Generating',
    isIdle: true,
    countdown: false,
  },
  countdown: {
    ja: '自動更新まであと{time}',
    en: 'Auto-update in {time}',
    isIdle: true,
    countdown: true,
  },
  generating: {
    ja: 'ルール生成中...',
    en: 'Generating Rules...',
    isIdle: false,
    countdown: false,
  },
  thinking: {
    ja: '次のルールを思考中...',
    en: 'Thinking...',
    isIdle: false,
    countdown: false,
  },
};

let currentState = 'idle';
let isAnimating = false;
let autoLoopRunning = false;
let autoLoopTimer = null;
let flowRunning = false;  // フロー実行中フラグ
let textGenTimer = null;  // テキスト生成用タイマー

// ========================================
// DOM
// ========================================
const btnContainer = document.getElementById('btn-container');
const actionButton = document.getElementById('action-button');
const btnJa = document.getElementById('btn-ja');
const btnEn = document.getElementById('btn-en');
const progressFill = document.getElementById('progress-fill');
const stateIndicator = document.getElementById('current-state');
const textPreview = document.getElementById('text-preview');
const timelineBar = document.getElementById('timeline-bar');

// ========================================
// パラメータ
// ========================================
const motionConfig = {
  distance: 16,
  outDuration: 280,
  inDuration: 280,
  stagger: 65,
  gap: 140,
  outEasing: 'ease-in',
  inEasing: 'ease-out',
  exitDirection: 'down',
  enterDirection: 'up',
  jaFirst: false,
  // ドレイン
  drainDuration: 680,
  drainEasing: 'ease-in-out',
  // テキスト生成
  textSpeed: 40,         // 1文字あたりms
  genDuration: 4000,     // 生成時間（ゲージ基準）
  // ゲージ
  gaugeDuration: 3000,
  gaugeEasing: 'ease-out',
};

// Easing functions
const easingFns = {
  'linear': t => t,
  'ease-in': t => t * t,
  'ease-out': t => 1 - (1 - t) * (1 - t),
  'ease-in-out': t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  'back-out': t => {
    const c = 1.70158;
    return 1 + (c + 1) * Math.pow(t - 1, 3) + c * Math.pow(t - 1, 2);
  },
};

function directionToVector(dir, dist) {
  switch (dir) {
    case 'up':    return { x: 0, y: -dist };
    case 'down':  return { x: 0, y: dist };
    case 'left':  return { x: -dist, y: 0 };
    case 'right': return { x: dist, y: 0 };
    default:      return { x: 0, y: dist };
  }
}

function wait(ms) {
  return new Promise(r => setTimeout(r, ms));
}

// ========================================
// スライダー接続
// ========================================
const sliders = [
  { id: 'slider-distance', valId: 'val-distance', key: 'distance' },
  { id: 'slider-out-duration', valId: 'val-out-duration', key: 'outDuration' },
  { id: 'slider-in-duration', valId: 'val-in-duration', key: 'inDuration' },
  { id: 'slider-stagger', valId: 'val-stagger', key: 'stagger' },
  { id: 'slider-gap', valId: 'val-gap', key: 'gap' },
  { id: 'slider-drain-duration', valId: 'val-drain-duration', key: 'drainDuration' },
  { id: 'slider-text-speed', valId: 'val-text-speed', key: 'textSpeed' },
  { id: 'slider-gen-duration', valId: 'val-gen-duration', key: 'genDuration' },
  { id: 'slider-gauge-duration', valId: 'val-gauge-duration', key: 'gaugeDuration' },
];

sliders.forEach(({ id, valId, key }) => {
  const slider = document.getElementById(id);
  const valEl = document.getElementById(valId);
  slider.addEventListener('input', () => {
    motionConfig[key] = parseFloat(slider.value);
    valEl.value = slider.value;
    updateTimeline();
  });
  valEl.addEventListener('change', () => {
    const num = parseFloat(valEl.value);
    if (isNaN(num)) { valEl.value = slider.value; return; }
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const clamped = Math.min(max, Math.max(min, num));
    slider.value = clamped;
    motionConfig[key] = clamped;
    valEl.value = clamped;
    updateTimeline();
  });
  valEl.addEventListener('focus', () => valEl.select());
});

document.getElementById('select-out-easing').addEventListener('change', e => motionConfig.outEasing = e.target.value);
document.getElementById('select-in-easing').addEventListener('change', e => motionConfig.inEasing = e.target.value);
document.getElementById('select-drain-easing').addEventListener('change', e => motionConfig.drainEasing = e.target.value);
document.getElementById('select-gauge-easing').addEventListener('change', e => motionConfig.gaugeEasing = e.target.value);

// 方向ボタン
function setupDirButtons(containerId, configKey) {
  const el = document.getElementById(containerId);
  el.addEventListener('click', e => {
    const btn = e.target.closest('button[data-dir]');
    if (!btn) return;
    motionConfig[configKey] = btn.dataset.dir;
    el.querySelectorAll('button').forEach(b => {
      const isActive = b === btn;
      b.style.background = isActive ? '#000' : '#fff';
      b.style.color = isActive ? '#fff' : '#000';
      b.style.borderColor = isActive ? '#000' : '#ccc';
    });
  });
}
setupDirButtons('exit-dir-buttons', 'exitDirection');
setupDirButtons('enter-dir-buttons', 'enterDirection');

document.getElementById('order-buttons').addEventListener('click', e => {
  const btn = e.target.closest('button[data-order]');
  if (!btn) return;
  motionConfig.jaFirst = btn.dataset.order === 'ja-first';
  document.getElementById('order-buttons').querySelectorAll('button').forEach(b => {
    const isActive = b === btn;
    b.style.background = isActive ? '#000' : '#fff';
    b.style.color = isActive ? '#fff' : '#000';
    b.style.borderColor = isActive ? '#000' : '#ccc';
  });
});

// ========================================
// タイムライン表示
// ========================================
function updateTimeline() {
  const exitDur = motionConfig.outDuration + motionConfig.stagger;
  const drainDur = motionConfig.drainDuration;
  const gapDur = motionConfig.gap;
  const enterDur = motionConfig.inDuration + motionConfig.stagger;

  // 直列: EXIT → DRAIN → GAP → ENTER → TEXT START
  const drainStart = exitDur;
  const gapStart = drainStart + drainDur;
  const enterStart = gapStart + gapDur;
  const textStart = enterStart + enterDur;
  const totalDur = textStart + 100; // テキスト開始マーカー分

  const phases = [
    { cls: 'tl-exit', start: 0, dur: exitDur, label: `EXIT ${exitDur}ms` },
    { cls: 'tl-drain', start: drainStart, dur: drainDur, label: `DRAIN ${drainDur}ms` },
    { cls: 'tl-gap', start: gapStart, dur: gapDur, label: `GAP ${gapDur}ms` },
    { cls: 'tl-enter', start: enterStart, dur: enterDur, label: `ENTER ${enterDur}ms` },
    { cls: 'tl-text', start: textStart, dur: 100, label: `TEXT▶` },
  ];

  timelineBar.innerHTML = '';
  phases.forEach(p => {
    if (p.dur <= 0) return;
    const div = document.createElement('div');
    div.className = 'tl-phase ' + p.cls;
    div.style.left = (p.start / totalDur * 100) + '%';
    div.style.width = (p.dur / totalDur * 100) + '%';
    div.textContent = p.label;
    timelineBar.appendChild(div);
  });
}
updateTimeline();

// ========================================
// アニメーション
// ========================================
function animateElement(el, params) {
  return new Promise(resolve => {
    const start = performance.now();
    const { fromX = 0, toX = 0, fromY = 0, toY = 0, fromOpacity, toOpacity, duration, easing } = params;
    const easingFn = easingFns[easing] || easingFns['linear'];
    function loop(now) {
      const rawT = Math.min(1, (now - start) / duration);
      const t = easingFn(rawT);
      el.style.transform = `translate(${fromX + (toX - fromX) * t}px, ${fromY + (toY - fromY) * t}px)`;
      el.style.opacity = fromOpacity + (toOpacity - fromOpacity) * t;
      if (rawT < 1) requestAnimationFrame(loop);
      else resolve();
    }
    requestAnimationFrame(loop);
  });
}

// ========================================
// ドレインアニメーション（Promise返却、await可能）
// ========================================
function drainTransition(fromIdle) {
  return new Promise(resolve => {
    const dur = motionConfig.drainDuration;
    const easing = motionConfig.drainEasing;

    if (fromIdle) {
      // idle → generating: fill=100%で黒維持→.idle除去→ドレインで白露出
      progressFill.style.transition = '';
      progressFill.style.width = '100%';
      void progressFill.offsetWidth;
      btnContainer.classList.remove('idle');
      btnContainer.classList.add('generating-state');
      actionButton.classList.add('generating');
    } else {
      // generating → idle: .idle先付けで背景黒→ドレインでfill除去
      btnContainer.classList.add('idle');
      btnContainer.classList.remove('generating-state');
      actionButton.classList.remove('generating');
      if (parseFloat(progressFill.style.width) < 100) {
        progressFill.style.transition = '';
        progressFill.style.width = '100%';
        void progressFill.offsetWidth;
      }
    }

    progressFill.style.transition = `width ${dur}ms ${easing}`;
    progressFill.style.width = '0%';
    setTimeout(() => {
      progressFill.style.transition = '';
      resolve();
    }, dur);
  });
}

// ========================================
// テキストトランジション
// ========================================
async function transitionToState(newState, options = {}) {
  if (isAnimating) return;
  if (newState === currentState) return;
  isAnimating = true;

  const fromState = STATES[currentState];
  const toState = STATES[newState];
  const dist = motionConfig.distance;
  const exitVec = directionToVector(motionConfig.exitDirection, dist);
  const enterVec = directionToVector(motionConfig.enterDirection, dist);
  const wasIdle = fromState.isIdle;
  const toIdle = toState.isIdle;

  // ---- EXIT ----
  const exitFirst = motionConfig.jaFirst ? btnJa : btnEn;
  const exitSecond = motionConfig.jaFirst ? btnEn : btnJa;

  const exitP1 = animateElement(exitFirst, {
    toX: exitVec.x, toY: exitVec.y,
    fromOpacity: 1, toOpacity: 0,
    duration: motionConfig.outDuration,
    easing: motionConfig.outEasing,
  });
  await wait(motionConfig.stagger);
  const exitP2 = animateElement(exitSecond, {
    toX: exitVec.x, toY: exitVec.y,
    fromOpacity: 1, toOpacity: 0,
    duration: motionConfig.outDuration,
    easing: motionConfig.outEasing,
  });
  await exitP1;
  await exitP2;

  // ---- テキスト差し替え ----
  if (toState.countdown) {
    const timeStr = formatTime(countdownSeconds);
    btnJa.innerHTML = toState.ja.replace('{time}',
      `<span class="countdown-time" id="countdown-ja-time">${timeStr}</span>`);
    btnEn.innerHTML = toState.en.replace('{time}',
      `<span class="countdown-time" id="countdown-en-time">${timeStr}</span>`);
  } else {
    btnJa.textContent = toState.ja;
    btnEn.textContent = toState.en;
  }

  // ---- クラス切り替え＋ドレイン（直列）----
  if (wasIdle && !toIdle) {
    // idle → generating: fill=100%で黒維持→.idle除去→ドレインで白露出
    await drainTransition(true);
  } else if (!wasIdle && toIdle) {
    // generating → idle: .idle先付け→ドレインで黒に
    await drainTransition(false);
  } else if (toIdle) {
    actionButton.classList.remove('generating');
    btnContainer.classList.remove('generating-state');
    btnContainer.classList.add('idle');
  } else {
    actionButton.classList.add('generating');
    btnContainer.classList.add('generating-state');
    btnContainer.classList.remove('idle');
  }

  // カウントダウン管理
  if (toState.countdown) startCountdown();
  else stopCountdown();

  // 初期位置
  btnJa.style.transform = `translate(${-enterVec.x}px, ${-enterVec.y}px)`;
  btnJa.style.opacity = '0';
  btnEn.style.transform = `translate(${-enterVec.x}px, ${-enterVec.y}px)`;
  btnEn.style.opacity = '0';

  await wait(motionConfig.gap);

  // ---- ENTER ----
  const enterP1 = animateElement(btnJa, {
    fromX: -enterVec.x, fromY: -enterVec.y,
    fromOpacity: 0, toOpacity: 1,
    duration: motionConfig.inDuration,
    easing: motionConfig.inEasing,
  });
  await wait(motionConfig.stagger);
  const enterP2 = animateElement(btnEn, {
    fromX: -enterVec.x, fromY: -enterVec.y,
    fromOpacity: 0, toOpacity: 1,
    duration: motionConfig.inDuration,
    easing: motionConfig.inEasing,
  });
  await enterP1;
  await enterP2;

  // クリーンアップ
  btnJa.style.transform = '';
  btnJa.style.opacity = '';
  btnEn.style.transform = '';
  btnEn.style.opacity = '';

  currentState = newState;
  isAnimating = false;
  updateStateButtons();
  updateStateIndicator();
}

// ========================================
// テキスト生成シミュレーション
// ========================================
const DEMO_RULES = [
  {
    num: '#42',
    ja: 'ゲームの開始時、各プレイヤーは手札を5枚引き、そのうち2枚を場に伏せる。伏せたカードは、第三章の条件を満たすまで公開できない。',
    en: 'At the start of the game, each player draws 5 cards and places 2 of them face down on the field. Face-down cards cannot be revealed until the conditions of Chapter 3 are met.',
  },
];

let textGenCancelled = false;

function startTextGeneration() {
  textGenCancelled = false;
  textPreview.innerHTML = '';

  const rule = DEMO_RULES[0];
  const jaChars = rule.ja.split('');
  let idx = 0;

  // ルール構造を作成（index.htmlと同じDOM構造）
  const ruleItem = document.createElement('div');
  ruleItem.className = 'rule-item';

  const ruleNumber = document.createElement('span');
  ruleNumber.className = 'rule-number generating';
  ruleNumber.textContent = rule.num;

  const ruleContent = document.createElement('div');
  ruleContent.className = 'rule-content';

  const ruleJa = document.createElement('p');
  ruleJa.className = 'rule-ja generating';

  const ruleEn = document.createElement('p');
  ruleEn.className = 'rule-en generating';
  ruleEn.textContent = rule.en;
  ruleEn.style.display = 'none'; // 日本語タイプ完了後に表示

  ruleContent.appendChild(ruleJa);
  ruleContent.appendChild(ruleEn);
  ruleItem.appendChild(ruleNumber);
  ruleItem.appendChild(ruleContent);
  textPreview.appendChild(ruleItem);

  // キャレット追加
  const caret = document.createElement('span');
  caret.className = 'caret generating';
  ruleJa.appendChild(caret);

  function addChar() {
    if (textGenCancelled || idx >= jaChars.length) {
      // タイプ完了 → キャレット除去、英語表示、generatingクラス除去
      const c = ruleJa.querySelector('.caret');
      if (c) c.remove();
      ruleEn.style.display = '';
      ruleJa.classList.remove('generating');
      ruleEn.classList.remove('generating');
      ruleNumber.classList.remove('generating');
      return;
    }

    // キャレットの前に文字を挿入
    const c = ruleJa.querySelector('.caret');
    if (c) {
      ruleJa.insertBefore(document.createTextNode(jaChars[idx]), c);
    } else {
      ruleJa.appendChild(document.createTextNode(jaChars[idx]));
    }

    // スクロール追従
    textPreview.scrollTop = textPreview.scrollHeight;

    idx++;
    textGenTimer = setTimeout(addChar, motionConfig.textSpeed + Math.random() * motionConfig.textSpeed * 0.5);
  }

  addChar();
}

function stopTextGeneration() {
  textGenCancelled = true;
  if (textGenTimer) { clearTimeout(textGenTimer); textGenTimer = null; }
}

// ========================================
// フロー実行（ボタン押下→生成→完了の一連）
// ========================================
async function runFlow() {
  if (flowRunning || isAnimating) return;
  flowRunning = true;

  const flowBtn = document.getElementById('btn-run-flow');
  flowBtn.textContent = '■ 実行中...';
  flowBtn.classList.add('active');

  // 初期状態がidleでなければリセット
  if (currentState !== 'idle') {
    resetAll();
    await wait(100);
  }

  // 1. idle → generating（テキスト退場→ドレイン→テキスト出現、直列）
  await transitionToState('generating');

  // 2. モーション完了後にテキスト生成開始 + ゲージ増加
  startTextGeneration();
  await animateGauge(0, 100, motionConfig.gaugeDuration, motionConfig.gaugeEasing);

  // 3. 少し待つ
  await wait(500);

  // 4. テキスト生成停止
  stopTextGeneration();

  // 5. generating → idle（ドレイン付きモーション）
  // ゲージを利用: 現在100%なのでそこからドレイン
  await transitionToState('idle');

  flowBtn.textContent = '▶ フロー実行（ボタン押下→生成→完了）';
  flowBtn.classList.remove('active');
  flowRunning = false;
}

document.getElementById('btn-run-flow').addEventListener('click', runFlow);

// コンテナクリックでフロー実行
btnContainer.addEventListener('click', () => {
  if (currentState === 'idle' && !flowRunning) {
    runFlow();
  }
});

// ========================================
// リセット
// ========================================
function resetAll() {
  stopTextGeneration();
  stopGauge();
  stopCountdown();
  if (autoLoopTimer) clearTimeout(autoLoopTimer);
  autoLoopRunning = false;
  flowRunning = false;
  isAnimating = false;

  progressFill.style.transition = '';
  progressFill.style.width = '0%';
  btnContainer.classList.remove('generating-state');
  btnContainer.classList.add('idle');
  actionButton.classList.remove('generating');
  btnJa.textContent = STATES.idle.ja;
  btnEn.textContent = STATES.idle.en;
  btnJa.style.transform = '';
  btnJa.style.opacity = '';
  btnEn.style.transform = '';
  btnEn.style.opacity = '';
  currentState = 'idle';
  textPreview.innerHTML = '';
  updateStateButtons();
  updateStateIndicator();

  const loopBtn = document.getElementById('btn-auto-loop');
  loopBtn.textContent = '▶ 自動ループ開始';
  loopBtn.classList.remove('active');
  const flowBtn = document.getElementById('btn-run-flow');
  flowBtn.textContent = '▶ フロー実行（ボタン押下→生成→完了）';
  flowBtn.classList.remove('active');
}

document.getElementById('btn-reset').addEventListener('click', resetAll);

// ========================================
// 状態ボタン（個別テスト）
// ========================================
const stateButtonsContainer = document.getElementById('state-buttons');
stateButtonsContainer.addEventListener('click', e => {
  const btn = e.target.closest('button[data-state]');
  if (!btn || flowRunning) return;
  transitionToState(btn.dataset.state);
});

function updateStateButtons() {
  stateButtonsContainer.querySelectorAll('button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.state === currentState);
  });
}

function updateStateIndicator() {
  const labels = {
    idle: '待機中（idle）',
    countdown: 'カウントダウン（countdown）',
    generating: '生成中（generating）',
    thinking: '思考中（thinking）',
  };
  stateIndicator.textContent = labels[currentState] || currentState;
}

// ========================================
// ゲージアニメーション
// ========================================
let gaugeAnimId = null;

function animateGauge(from, to, duration, easing) {
  return new Promise(resolve => {
    if (gaugeAnimId) cancelAnimationFrame(gaugeAnimId);
    const easingFn = easingFns[easing] || easingFns['linear'];
    const startTime = performance.now();

    function tick(now) {
      const rawT = Math.min(1, (now - startTime) / duration);
      const t = easingFn(rawT);
      const val = from + (to - from) * t;
      progressFill.style.width = val + '%';
      if (rawT < 1) {
        gaugeAnimId = requestAnimationFrame(tick);
      } else {
        progressFill.style.width = to + '%';
        gaugeAnimId = null;
        resolve();
      }
    }
    gaugeAnimId = requestAnimationFrame(tick);
  });
}

function stopGauge() {
  if (gaugeAnimId) {
    cancelAnimationFrame(gaugeAnimId);
    gaugeAnimId = null;
  }
}

// ========================================
// カウントダウン
// ========================================
let countdownInterval = null;
let countdownSeconds = 120;
let countdownAutoReturn = true;
const COUNTDOWN_STARTS = [120, 60, 10];
let countdownStartIdx = 0;

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${String(s).padStart(2, '0')}`;
}

function startCountdown() {
  stopCountdown();
  countdownSeconds = COUNTDOWN_STARTS[countdownStartIdx];
  countdownStartIdx = (countdownStartIdx + 1) % COUNTDOWN_STARTS.length;
  const endSeconds = countdownSeconds - 10;
  updateCountdownDisplay();
  countdownInterval = setInterval(() => {
    countdownSeconds--;
    updateCountdownDisplay();
    if (countdownSeconds <= endSeconds || countdownSeconds <= 0) {
      stopCountdown();
      if (countdownAutoReturn && currentState === 'countdown') {
        transitionToState('idle');
      }
    }
  }, 1000);
}

function stopCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

function updateCountdownDisplay() {
  const timeStr = formatTime(Math.max(0, countdownSeconds));
  const jaTime = document.getElementById('countdown-ja-time');
  const enTime = document.getElementById('countdown-en-time');
  if (jaTime) jaTime.textContent = timeStr;
  if (enTime) enTime.textContent = timeStr;
}

// ========================================
// 自動ループ
// ========================================
const stateOrder = ['idle', 'generating', 'idle'];

document.getElementById('btn-auto-loop').addEventListener('click', function() {
  if (autoLoopRunning) {
    autoLoopRunning = false;
    this.textContent = '▶ 自動ループ開始';
    this.classList.remove('active');
    if (autoLoopTimer) clearTimeout(autoLoopTimer);
    return;
  }

  autoLoopRunning = true;
  this.textContent = '■ 停止';
  this.classList.add('active');

  let step = 0;

  async function loop() {
    if (!autoLoopRunning) return;
    step = (step + 1) % stateOrder.length;
    const nextState = stateOrder[step];
    await transitionToState(nextState);
    if (!autoLoopRunning) return;
    autoLoopTimer = setTimeout(loop, 1500);
  }
  loop();
});

// ========================================
// 初期状態
// ========================================
// color は CSS で制御（.action-button = #FFFFFF, .action-button.generating = グレー）
// インラインスタイルで上書きしない

</script>
</body>
</html>
