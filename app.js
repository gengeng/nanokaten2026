/**
 * 完成しないゲーム - メインアプリケーション
 */

// ========================================
// 設定
// ========================================
const VERSION = '1.0.55';
const SESSION_ID = Math.random().toString(36).slice(2, 8);

const CONFIG = {
  spreadsheetId: '1eBk4OIyFRCGJYUgZ15bavQl5pngufGKUYm18Y0evJQg',
  rulesSheetId: '487776336',
  typewriterSpeed: 8, // 1-100
  // URLパラメータまたはリモート設定から取得
  startRule: parseInt(new URLSearchParams(window.location.search).get('startRule')) || 8,
  // GAS直接呼び出し（ステータス記録用）
  statusGasUrl: 'https://script.google.com/macros/s/AKfycbw2y_-q8WI8M4EwnNHWtH3ss73x2bMo6VlpdPiTMfY8RLfmbujNhZh16fudlHUnFms3TQ/exec',

  // ゲージ設定
  gaugeDuration: 54000,    // 0→90%の時間（ms）
  gaugePausePoint: 0.90,   // 停止ポイント（0-1）
  gaugePausePointVariance: 0.05, // 停止ポイントゆらぎ（±5%）
  gaugePauseDuration: 1000,      // 停止時間（ms）
  gaugePauseDurationVariance: 0.3, // 停止時間ゆらぎ（±30%）
  gaugeWaveAmplitude: 0.015, // ゆらぎの振幅（±1.5%）
  gaugeWaveFrequency: 0.3,   // 波の周波数（Hz）
  gaugeDrainDuration: 680,   // ゲージ100→0のドレイン時間（ms）
  gaugeDrainEasing: 'ease-in-out', // ドレインのイージング

  // タイポ設定
  typoChance: 0.05,        // タイポ確率（0-1）
  typoPause: 4,            // タイポ後の停止（倍率）

  // 切り替え停止（倍率）
  pauseNumToJa: 6,         // #番号 → 日本語
  pauseJaToEn: 7.5,        // 日本語 → 英語
  pauseEnToNum: 24,        // 英語 → 次の#番号（黒化後の間、100ms単位）

  // 句読点停止（倍率）
  pauseKuten: 9,           // 句点（。）
  pauseTouten: 7.5,        // 読点（、）
  pauseOpenBracket: 4,     // 開き括弧（「）
  pauseCloseBracket: 4,    // 閉じ括弧（」）
  pausePeriod: 6.5,        // ピリオド（.）
  pauseComma: 3,           // カンマ（,）
  pauseSpace: 0.5,         // スペース

  // ランダム幅
  varianceJa: 0.64,        // 日本語（±64%）
  varianceEn: 0.64,        // 英語（±64%）

  // 自動更新
  autoGenerateDelay: 180000, // 自動更新までの待ち時間（ms）= 3分、0で無効
};

// ========================================
// 状態管理
// ========================================
const state = {
  rules: [],
  segments: [],  // 「、」で分割されたセグメント
  currentSegmentIndex: 0,
  isGenerating: false,
  isThinking: false,  // 文字出力完了後、ゲージ待ち状態
  isPaused: false,  // リモートからの一時停止フラグ
  isAutoScroll: true,
  typewriterSpeed: CONFIG.typewriterSpeed,
  currentRuleElement: null,  // 現在表示中のルール要素
  currentJaElement: null,    // 現在表示中の日本語要素
  currentEnElement: null,    // 現在表示中の英語要素
  currentNumberElement: null, // 現在表示中の番号要素
  currentCaret: null,         // 画面上の唯一のキャレット
  pendingComponent: null,     // ルール完了後に左カラム表示する内容物データ
  pendingHands: null,         // ルール完了後に左カラム表示する手データ

  // デバッグ用設定（リアルタイム変更可能）
  gaugeDuration: CONFIG.gaugeDuration,
  gaugePausePoint: CONFIG.gaugePausePoint,
  gaugePausePointVariance: CONFIG.gaugePausePointVariance,
  gaugePauseDuration: CONFIG.gaugePauseDuration,
  gaugePauseDurationVariance: CONFIG.gaugePauseDurationVariance,
  gaugeWaveAmplitude: CONFIG.gaugeWaveAmplitude,
  gaugeWaveFrequency: CONFIG.gaugeWaveFrequency,
  gaugeDrainDuration: CONFIG.gaugeDrainDuration,
  gaugeDrainEasing: CONFIG.gaugeDrainEasing,
  typoChance: CONFIG.typoChance,
  typoPause: CONFIG.typoPause,
  pauseNumToJa: CONFIG.pauseNumToJa,
  pauseJaToEn: CONFIG.pauseJaToEn,
  pauseEnToNum: CONFIG.pauseEnToNum,
  pauseKuten: CONFIG.pauseKuten,
  pauseTouten: CONFIG.pauseTouten,
  pauseOpenBracket: CONFIG.pauseOpenBracket,
  pauseCloseBracket: CONFIG.pauseCloseBracket,
  pausePeriod: CONFIG.pausePeriod,
  pauseComma: CONFIG.pauseComma,
  pauseSpace: CONFIG.pauseSpace,
  varianceJa: CONFIG.varianceJa,
  varianceEn: CONFIG.varianceEn,
  autoGenerateDelay: CONFIG.autoGenerateDelay,
};

// URLパラメータでデバッグモード判定（デフォルトでオン）
let isDebugMode = true;

// タイトル5回タップでデバッグモード
let titleTapCount = 0;
let titleTapTimer = null;

// ========================================
// DOM要素
// ========================================
const elements = {
  componentsJa: document.getElementById('components-ja'),
  componentsEn: document.getElementById('components-en'),
  handsJa: document.getElementById('hands-ja'),
  handsEn: document.getElementById('hands-en'),
  ruleList: document.getElementById('rule-list'),
  actionButton: document.getElementById('action-button'),
  actionButtonContainer: document.getElementById('action-button-container'),
  progressFill: document.getElementById('progress-fill'),
  gameVersion: document.getElementById('game-version'),
};

// ========================================
// Googleスプレッドシート データ取得
// ========================================
function getSheetUrl(sheetId, options = {}) {
  let url = `https://docs.google.com/spreadsheets/d/${CONFIG.spreadsheetId}/gviz/tq?tqx=out:json&gid=${sheetId}`;
  if (options.headers !== undefined) {
    url += `&headers=${options.headers}`;
  }
  return url;
}

function parseGoogleSheetResponse(text) {
  const jsonString = text.match(/google\.visualization\.Query\.setResponse\(([\s\S]*)\);?/);
  if (!jsonString) throw new Error('Invalid response format');
  return JSON.parse(jsonString[1]);
}

async function fetchSheetData(sheetId, options = {}) {
  const response = await fetch(getSheetUrl(sheetId, options));
  const text = await response.text();
  return parseGoogleSheetResponse(text);
}

// ルールテキスト内の {id:XXXXXXXX} を #N に置換
function resolveIdReferences(rules) {
  // id → num のマップを作成
  const idToNum = new Map();
  rules.forEach(rule => {
    if (rule.id) {
      idToNum.set(rule.id, rule.num);
    }
  });

  // 各ルールのja/enを置換
  const pattern = /\{id:([a-zA-Z0-9]+)\}/g;
  return rules.map(rule => ({
    ...rule,
    ja: rule.ja.replace(pattern, (match, id) => {
      const num = idToNum.get(id);
      return num !== undefined ? `#${num}` : match;
    }),
    en: rule.en.replace(pattern, (match, id) => {
      const num = idToNum.get(id);
      return num !== undefined ? `#${num}` : match;
    }),
  }));
}

// ========================================
// ルールの読み込みとセグメント化
// ========================================
async function loadRules() {
  try {
    const data = await fetchSheetData(CONFIG.rulesSheetId);
    const rows = data.table.rows;

    // config列を1行目から取得（config_startRule=L列, config_isPaused=M列）
    const remoteConfig = {};
    if (rows.length > 0 && rows[0].c) {
      const firstRow = rows[0].c;
      if (firstRow[11]?.v !== undefined && firstRow[11]?.v !== null) {
        remoteConfig.startRule = firstRow[11].v;
      }
      if (firstRow[12]?.v !== undefined && firstRow[12]?.v !== null) {
        remoteConfig.isPaused = firstRow[12].v;
      }
    }
    state.remoteConfig = remoteConfig;
    console.log('Remote config from rules sheet:', JSON.stringify(remoteConfig));

    state.rules = rows.map(row => {
      const cells = row.c;
      if (!cells) return null;

      return {
        num: cells[0]?.v || 0,           // A: num
        id: cells[1]?.v || '',           // B: id
        major: cells[2]?.v === true || cells[2]?.v === 'TRUE',  // C: major
        ja: cells[3]?.v || '',           // D: ja
        en: cells[4]?.v || '',           // E: en
        // cells[5] = auto_translate (skip)
        jankenJa: cells[6]?.v || '',     // G: janken_ja
        jankenEn: cells[7]?.v || '',     // H: janken_en
        // cells[8] = auto_translate_janken_en (skip)
        componentJa: cells[9]?.v || '',  // J: component_ja
        componentEn: cells[10]?.v || '', // K: component_en
      };
    }).filter(rule => rule && rule.ja);

    // ID参照を解決（{id:XXXXXXXX} → #N）
    state.rules = resolveIdReferences(state.rules);

    // キャッシュに保存
    localStorage.setItem('cachedRules', JSON.stringify({ version: VERSION, data: state.rules }));

    // セグメント化（「、」で分割）
    state.segments = prepareSegments(state.rules);

    console.log(`Loaded ${state.rules.length} rules, ${state.segments.length} segments`);
  } catch (error) {
    console.error('Failed to load rules:', error);
    reportStatus('エラー');
    // キャッシュから復帰を試みる
    const rawCached = localStorage.getItem('cachedRules');
    if (rawCached) {
      const cached = JSON.parse(rawCached);
      // バージョン付きキャッシュか旧形式かを判定
      if (cached?.version === VERSION && cached.data) {
        console.log('Loading rules from versioned cache');
        state.rules = cached.data;
      } else if (Array.isArray(cached)) {
        console.log('Loading rules from legacy cache (clearing)');
        localStorage.removeItem('cachedRules');
        return;  // 旧キャッシュは使わない
      } else {
        console.log('Cache version mismatch, clearing');
        localStorage.removeItem('cachedRules');
        return;
      }
      state.segments = prepareSegments(state.rules);
      console.log(`Loaded ${state.rules.length} rules from cache`);
    }
  }
}

function prepareSegments(rules) {
  const segments = [];
  rules.forEach(rule => {
    // 「、」の後ろで分割（「、」を含む）
    const jaParts = rule.ja.split(/(?<=、)/);

    jaParts.forEach((part, i) => {
      segments.push({
        num: rule.num,
        jaSegment: part,
        enFull: i === jaParts.length - 1 ? rule.en : null,  // 最後のセグメントのみ英語
        isFirst: i === 0,  // このルールの最初のセグメントか
        isLast: i === jaParts.length - 1,  // このルールの最後のセグメントか
        // 最初のセグメントにのみ内容物・じゃんけん情報を付与
        componentJa: i === 0 ? rule.componentJa : '',
        componentEn: i === 0 ? rule.componentEn : '',
        jankenJa: i === 0 ? rule.jankenJa : '',
        jankenEn: i === 0 ? rule.jankenEn : '',
        major: i === 0 ? rule.major : false,
      });
    });
  });
  return segments;
}

// ========================================
// 左パネル：内容物・じゃんけんの手
// ========================================
let componentCount = 0;  // 表示済み内容物の数
let handsCount = 0;      // 表示済みじゃんけんの手の数
let leftPanelQueue = Promise.resolve();  // 左パネルタイプライターのキュー

// 指定ルール番号までのバージョンを計算
function calculateVersion(rules, upToNum) {
  let major = 1;
  let minor = 0;
  for (const rule of rules) {
    if (Number(rule.num) > Number(upToNum)) break;
    if (rule.major) {
      major++;
      minor = 0;
    } else {
      minor++;
    }
  }
  return { major, minor };
}

function updateVersionDisplay(major, minor, animate = true) {
  const newText = `${major}.${minor}`;
  const container = document.getElementById('ver-digits');
  if (!container) return;

  const oldText = container.dataset.value || '';
  container.dataset.value = newText;

  // 初期表示またはアニメーション不要の場合
  if (!animate || !oldText) {
    container.textContent = newText;
    return;
  }

  // 同じなら何もしない
  if (oldText === newText) return;

  // 桁ごとの差分アニメーション
  const maxLen = Math.max(oldText.length, newText.length);
  container.textContent = '';

  for (let i = 0; i < maxLen; i++) {
    const oldChar = oldText[i] || '';
    const newChar = newText[i] || '';

    if (oldChar === newChar) {
      container.appendChild(document.createTextNode(newChar));
    } else {
      // 数値比較で方向を決定（増加→上へ、減少→下へ）
      const oldNum = parseInt(oldChar);
      const newNum = parseInt(newChar);
      const goUp = isNaN(oldNum) || isNaN(newNum) || newNum >= oldNum;
      const dir = goUp ? 'up' : 'down';

      // スライドアニメーション
      const wrapper = document.createElement('span');
      wrapper.className = 'ver-digit';

      const out = document.createElement('span');
      out.className = `ver-digit-out ver-${dir}`;
      out.textContent = oldChar;

      const inn = document.createElement('span');
      inn.className = `ver-digit-in ver-${dir}`;
      inn.textContent = newChar;

      wrapper.appendChild(out);
      wrapper.appendChild(inn);
      container.appendChild(wrapper);

      // アニメーション完了後にクリーンアップ
      inn.addEventListener('animationend', () => {
        wrapper.replaceWith(document.createTextNode(newChar));
      }, { once: true });
    }
  }
}

// 即時表示（初期表示用）
function addComponentInstant(ja, en) {
  if (componentCount > 0) {
    elements.componentsJa.appendChild(document.createTextNode(' / '));
    elements.componentsEn.appendChild(document.createTextNode(' / '));
  }
  elements.componentsJa.appendChild(document.createTextNode(ja));
  elements.componentsEn.appendChild(document.createTextNode(en));
  componentCount++;
}

function addHandInstant(ja, en) {
  if (handsCount > 0) {
    elements.handsJa.appendChild(document.createTextNode(' / '));
    elements.handsEn.appendChild(document.createTextNode(' / '));
  }
  elements.handsJa.appendChild(document.createTextNode(ja));
  elements.handsEn.appendChild(document.createTextNode(en));
  handsCount++;
}

// タイプライター表示（生成中用、キューで逐次実行）
function queueLeftPanelTypewriter(type, ja, en) {
  leftPanelQueue = leftPanelQueue.then(() => typewriterLeftPanel(type, ja, en));
}

async function typewriterLeftPanel(type, ja, en) {
  const isComponent = type === 'component';
  const jaEl = isComponent ? elements.componentsJa : elements.handsJa;
  const enEl = isComponent ? elements.componentsEn : elements.handsEn;
  const count = isComponent ? componentCount : handsCount;

  // 区切りを追加
  if (count > 0) {
    if (isComponent) {
      jaEl.appendChild(document.createTextNode(' / '));
      enEl.appendChild(document.createTextNode(' / '));
    } else {
      jaEl.appendChild(document.createTextNode(' / '));
      enEl.appendChild(document.createTextNode(' / '));
    }
  }

  // ハイライトspan作成
  const jaHl = document.createElement('span');
  jaHl.className = 'left-highlight';
  jaEl.appendChild(jaHl);
  const enHl = document.createElement('span');
  enHl.className = 'left-highlight';
  enEl.appendChild(enHl);

  // 日本語をタイプライター表示（span内に追加）
  for (const char of ja) {
    jaHl.appendChild(document.createTextNode(char));
    await delay(getTypewriterDelay(char));
  }

  // 英語をタイプライター表示（span内に追加）
  for (const char of en) {
    enHl.appendChild(document.createTextNode(char));
    await delay(getTypewriterDelayEn(char));
  }

  if (isComponent) {
    componentCount++;
  } else {
    handsCount++;
  }
}

// 左パネルハイライト解除
function removeLeftPanelHighlights() {
  const highlights = document.querySelectorAll('.left-highlight');
  highlights.forEach(span => {
    span.classList.add('hl-removing');
    span.addEventListener('animationend', () => {
      const parent = span.parentNode;
      if (!parent) return;
      while (span.firstChild) {
        parent.insertBefore(span.firstChild, span);
      }
      parent.removeChild(span);
    }, { once: true });
  });
}

// ========================================
// タイプライター表示
// ========================================
class Typewriter {
  constructor(element, options = {}) {
    this.element = element;
    this.onProgress = options.onProgress || (() => {});
    this.onComplete = options.onComplete || (() => {});
    this.isRunning = false;
    this.caret = null;
  }

  getDelay() {
    const normalized = state.typewriterSpeed / 100;
    const delay = 200 * Math.pow(0.05, normalized);
    return Math.max(10, Math.min(200, delay));
  }

  createCaret(isGenerating = false) {
    const caret = document.createElement('span');
    caret.className = 'caret';
    if (isGenerating) {
      caret.classList.add('generating');
    }
    return caret;
  }

  async type(text, options = {}) {
    const { generating = false } = options;
    this.isRunning = true;
    this.caret = this.createCaret(generating);

    const totalChars = text.length;

    for (let i = 0; i < text.length; i++) {
      if (!this.isRunning) break;

      const char = text[i];
      const textNode = document.createTextNode(char);

      if (this.caret.parentNode) {
        this.caret.parentNode.insertBefore(textNode, this.caret);
      } else {
        this.element.appendChild(textNode);
        this.element.appendChild(this.caret);
      }

      // 進捗コールバック
      this.onProgress((i + 1) / totalChars);

      if (state.isAutoScroll) {
        scrollToBottom();
      }

      await this.delay(this.getDelay());
    }

    this.isRunning = false;
    this.onComplete();
    return this.caret;  // キャレットを返す（思考状態用）
  }

  removeCaret() {
    if (this.caret && this.caret.parentNode) {
      this.caret.remove();
    }
    this.caret = null;
  }

  async think(duration = 1000) {
    if (this.caret) {
      this.caret.classList.add('thinking');
      await this.delay(duration);
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  stop() {
    this.isRunning = false;
  }
}

// ========================================
// ルール表示
// ========================================
function createRuleElement(num) {
  const ruleElement = document.createElement('div');
  ruleElement.className = 'rule-item';

  const numberElement = document.createElement('span');
  numberElement.className = 'rule-number generating';
  // 番号は空で作成（後でタイプライター表示）
  numberElement.textContent = '';
  numberElement.dataset.num = num;  // 番号を保存

  const contentElement = document.createElement('div');
  contentElement.className = 'rule-content';

  const jaElement = document.createElement('p');
  jaElement.className = 'rule-ja generating';

  const enElement = document.createElement('p');
  enElement.className = 'rule-en generating';

  contentElement.appendChild(jaElement);
  contentElement.appendChild(enElement);

  ruleElement.appendChild(numberElement);
  ruleElement.appendChild(contentElement);

  elements.ruleList.appendChild(ruleElement);

  return { ruleElement, numberElement, jaElement, enElement };
}

function makeCurrentRuleBlack() {
  // インク侵食の対象スパンを確定（まだフェード中のものも最終色へ）
  // → inline colorを削除して親のCSSカラーを継承させる
  // → .generating削除でCSS transitionにより黒にフェード
  [state.currentNumberElement, state.currentJaElement, state.currentEnElement].forEach(el => {
    if (!el) return;
    // インク侵食リストからクリア＆inline color除去
    inkFadeFinalizeElement(el);
    // spanのinline colorを除去 → 親のcolorを継承
    el.querySelectorAll('span[style*="color"]').forEach(span => {
      span.style.removeProperty('color');
    });
    // generating クラス削除 → CSS transition で黒へ
    el.classList.remove('generating');
  });
}

// ========================================
// ページタイトル更新（リモート監視用）
// ========================================
function updatePageTitle() {
  const currentSegment = state.segments[state.currentSegmentIndex - 1];
  const currentRuleNum = currentSegment ? currentSegment.num : CONFIG.startRule;

  let status = '待機中';
  if (state.isPaused) {
    status = '停止中';
  } else if (state.isGenerating) {
    status = '更新中';
  }

  document.title = `#${currentRuleNum} ${status}`;
}

// ========================================
// ステータス送信（GAS直接呼び出しでスプレッドシートに記録）
// ========================================
let lastReportedStatus = null;

function reportStatus(status) {
  if (!CONFIG.statusGasUrl) return;

  const currentSegment = state.segments[state.currentSegmentIndex - 1];
  const num = currentSegment ? currentSegment.num : CONFIG.startRule;
  const segment = `${state.currentSegmentIndex}/${state.segments.length}`;

  // 同じステータスなら送信しない
  const statusKey = `${num}-${status}`;
  if (statusKey === lastReportedStatus) return;
  lastReportedStatus = statusKey;

  // パラメータ組み立て
  const params = new URLSearchParams({
    timestamp: new Date().toISOString(),
    sessionId: SESSION_ID,
    num: num,
    segment: segment,
    status: status,
  });

  // リロード時のみuserAgent付与
  if (status === 'リロード') {
    params.set('userAgent', navigator.userAgent);
  }

  const url = `${CONFIG.statusGasUrl}?${params.toString()}`;

  fetch(url, { mode: 'no-cors' })
    .then(() => console.log(`Status: ${status} #${num} (${segment})`))
    .catch(e => console.error('Status report failed:', e));
}

// ========================================
// 多角形モーフィング設定
// ========================================
const morphConfig = {
  size: 24,
  verticesMin: 5,
  verticesMax: 7,
  morphDuration: 200,   // ms, ンぎゅ！の速さ
  holdDuration: 400,    // ms, ・・・の溜め
  irregularity: 0.53,   // 0=正多角形, 1=中心まで凹む
  scalePulse: 1.0,      // 変形時の膨らみ
  rotation: 0,          // 変形ごとの回転角度
  holdRotation: 0,      // hold中の回転速度（°/s）
  easing: 'ngyu',       // easing種類
  // 多角形→縦棒トランジション
  toBarDuration: 100,   // ms
  toBarEasing: 'ease-out',
  barWidth: 14,          // 縦棒の幅（%）
  barHeight: 100,        // 縦棒の高さ（%）
  // インク侵食（黒→グレーフェード）
  inkFadeDelay: 100,     // 打った後フェード開始までの待ち（ms）
  inkFadeDuration: 300,  // フェード所要時間（ms）
  inkFadeVariance: 0.05, // delay/durationの揺らぎ（±秒）
  inkFadeColor: 'rgba(165, 165, 165, 0.6)', // 最終色（generatingと同じ）
};

// ========================================
// インク侵食（Ink Fade）
// ========================================
let inkFadeCharSpans = []; // { el, birthTime, delay, duration }
let inkFadeRunning = false;

function inkFadeRandomize(base) {
  const v = morphConfig.inkFadeVariance * 1000; // 秒→ms
  return Math.max(0, base + (Math.random() * 2 - 1) * v);
}

// 文字をインク侵食対象として登録
function inkFadeRegister(spanEl) {
  inkFadeCharSpans.push({
    el: spanEl,
    birthTime: performance.now(),
    delay: inkFadeRandomize(morphConfig.inkFadeDelay),
    duration: inkFadeRandomize(morphConfig.inkFadeDuration),
  });
  if (!inkFadeRunning) {
    inkFadeRunning = true;
    requestAnimationFrame(inkFadeFadeLoop);
  }
}

// rAFで全文字の色を毎フレーム更新
function inkFadeFadeLoop(time) {
  if (inkFadeCharSpans.length === 0) {
    inkFadeRunning = false;
    return;
  }

  let allDone = true;
  for (const item of inkFadeCharSpans) {
    const age = time - item.birthTime;

    if (age < item.delay) {
      // まだ黒のまま
      item.el.style.color = '#000';
      allDone = false;
    } else if (age < item.delay + item.duration) {
      // フェード中：黒 → グレーに補間
      const t = (age - item.delay) / item.duration;
      const r = Math.round(165 * t);
      const a = 1 - 0.4 * t; // 1.0 → 0.6
      item.el.style.color = `rgba(${r}, ${r}, ${r}, ${a})`;
      allDone = false;
    } else {
      // フェード完了
      item.el.style.color = morphConfig.inkFadeColor;
    }
  }

  // 全完了でも古いスパンは維持（色の再適用は不要だがメモリ節約のため定期クリーンアップ）
  if (allDone) {
    inkFadeRunning = false;
    return;
  }

  requestAnimationFrame(inkFadeFadeLoop);
}

// ルール確定時：対象要素内の全スパンを最終色に固定し、リストからクリア
function inkFadeFinalizeElement(parentEl) {
  inkFadeCharSpans = inkFadeCharSpans.filter(item => {
    if (parentEl.contains(item.el)) {
      item.el.style.color = morphConfig.inkFadeColor;
      return false;
    }
    return true;
  });
}

// ========================================
// 多角形生成・補間
// ========================================

// Generate a polygon with N vertices
function generatePolygon(n, irregularity = 0) {
  const points = [];
  const angleStep = (Math.PI * 2) / n;
  const baseRotation = Math.random() * Math.PI * 2;
  const rMin = 50 * (1 - irregularity);
  for (let i = 0; i < n; i++) {
    const angle = baseRotation + angleStep * i;
    const r = rMin + Math.random() * (50 - rMin);
    const x = 50 + r * Math.cos(angle);
    const y = 50 + r * Math.sin(angle);
    points.push({ x, y });
  }
  return points;
}

// 多角形の面積を計算（Shoelace formula）
function polygonArea(points) {
  let area = 0;
  const n = points.length;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    area += points[i].x * points[j].y;
    area -= points[j].x * points[i].y;
  }
  return Math.abs(area) / 2;
}

// 面積を目標値にスケーリング（中心50,50基準）→ 0〜100に収める
function normalizeArea(points, targetArea) {
  const currentArea = polygonArea(points);
  if (currentArea < 0.01) return points;
  const scale = Math.sqrt(targetArea / currentArea);
  let scaled = points.map(p => ({
    x: 50 + (p.x - 50) * scale,
    y: 50 + (p.y - 50) * scale,
  }));

  const margin = 1;
  let maxDist = 0;
  for (const p of scaled) {
    maxDist = Math.max(maxDist,
      (p.x - 50) / (50 - margin),
      (50 - p.x) / (50 - margin),
      (p.y - 50) / (50 - margin),
      (50 - p.y) / (50 - margin),
    );
  }
  if (maxDist > 1) {
    scaled = scaled.map(p => ({
      x: 50 + (p.x - 50) / maxDist,
      y: 50 + (p.y - 50) / maxDist,
    }));
  }

  return scaled;
}

// 正五角形の面積 = 基準面積
const TARGET_AREA = 0.5 * 5 * 50 * 50 * Math.sin(2 * Math.PI / 5);

// 頂点保持リサンプリング
function resamplePolygon(points, targetCount) {
  const n = points.length;
  if (n === targetCount) return points.map(p => ({ ...p }));
  if (n >= targetCount) return points.slice(0, targetCount).map(p => ({ ...p }));

  const extra = targetCount - n;
  const edgeLengths = [];
  let totalLen = 0;
  for (let i = 0; i < n; i++) {
    const next = points[(i + 1) % n];
    const dx = next.x - points[i].x;
    const dy = next.y - points[i].y;
    const len = Math.sqrt(dx * dx + dy * dy);
    edgeLengths.push(len);
    totalLen += len;
  }

  const pointsPerEdge = edgeLengths.map(len =>
    totalLen > 0 ? Math.floor(extra * len / totalLen) : 0
  );

  let assigned = pointsPerEdge.reduce((a, b) => a + b, 0);
  let remaining = extra - assigned;
  const sortedEdges = edgeLengths.map((len, i) => ({ i, len }))
    .sort((a, b) => b.len - a.len);
  for (let k = 0; remaining > 0; k++, remaining--) {
    pointsPerEdge[sortedEdges[k % n].i]++;
  }

  const result = [];
  for (let i = 0; i < n; i++) {
    result.push({ ...points[i] });
    const next = points[(i + 1) % n];
    const k = pointsPerEdge[i];
    for (let j = 1; j <= k; j++) {
      const t = j / (k + 1);
      result.push({
        x: points[i].x + (next.x - points[i].x) * t,
        y: points[i].y + (next.y - points[i].y) * t,
      });
    }
  }

  return result;
}

// 回転オフセット＋正逆両方向を試して最小距離の対応づけを見つける
function findBestRotation(a, b) {
  const n = a.length;
  let bestOffset = 0;
  let bestDist = Infinity;
  let bestReverse = false;

  for (let reverse = 0; reverse <= 1; reverse++) {
    const bArr = reverse ? [...b].reverse() : b;
    for (let offset = 0; offset < n; offset++) {
      let totalDist = 0;
      for (let i = 0; i < n; i++) {
        const j = (i + offset) % n;
        const dx = a[i].x - bArr[j].x;
        const dy = a[i].y - bArr[j].y;
        totalDist += dx * dx + dy * dy;
      }
      if (totalDist < bestDist) {
        bestDist = totalDist;
        bestOffset = offset;
        bestReverse = !!reverse;
      }
    }
  }

  const bFinal = bestReverse ? [...b].reverse() : b;
  const rotated = [];
  for (let i = 0; i < n; i++) {
    rotated.push({ ...bFinal[(i + bestOffset) % n] });
  }
  return rotated;
}

// Lerp between two point arrays
function lerpPolygons(a, b, t) {
  return a.map((p, i) => ({
    x: p.x + (b[i].x - p.x) * t,
    y: p.y + (b[i].y - p.y) * t,
  }));
}

// Convert points to clip-path string
function toClipPath(points) {
  return `polygon(${points.map(p => `${p.x.toFixed(3)}% ${p.y.toFixed(3)}%`).join(', ')})`;
}

// ========================================
// Easing Functions
// ========================================
const easings = {
  'ngyu':        t => Math.pow(t, 4),
  'linear':      t => t,
  'ease-in':     t => t * t,
  'ease-out':    t => 1 - Math.pow(1 - t, 2),
  'ease-in-out': t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  'elastic':     t => {
    if (t === 0 || t === 1) return t;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * (2 * Math.PI / 3));
  },
  'back':        t => {
    const c = 1.70158;
    return (c + 1) * t * t * t - c * t * t;
  },
  'bounce':      t => {
    const t2 = 1 - t;
    if (t2 < 1/2.75) return 1 - 7.5625 * t2 * t2;
    if (t2 < 2/2.75) return 1 - (7.5625 * (t2 - 1.5/2.75) * (t2 - 1.5/2.75) + 0.75);
    if (t2 < 2.5/2.75) return 1 - (7.5625 * (t2 - 2.25/2.75) * (t2 - 2.25/2.75) + 0.9375);
    return 1 - (7.5625 * (t2 - 2.625/2.75) * (t2 - 2.625/2.75) + 0.984375);
  },
};

function getMorphEasing(t) {
  return (easings[morphConfig.easing] || easings['ngyu'])(t);
}

// ========================================
// 縦棒（Bar）形状
// ========================================
function getBarShape() {
  const w = morphConfig.barWidth / 2;
  const h = morphConfig.barHeight / 2;
  return [
    { x: 50 - w, y: 50 - h },
    { x: 50 + w, y: 50 - h },
    { x: 50 + w, y: 50 + h },
    { x: 50 - w, y: 50 + h },
  ];
}

// インライン用：要素全幅を使い切るbar clip-path
function getFullWidthBarClipPath() {
  const h = morphConfig.barHeight / 2;
  return toClipPath([
    { x: 0, y: 50 - h },
    { x: 100, y: 50 - h },
    { x: 100, y: 50 + h },
    { x: 0, y: 50 + h },
  ]);
}

function getBarPixelWidth() {
  return morphConfig.barWidth / 100 * morphConfig.size;
}

// ========================================
// 多角形モーフィング アニメーションループ
// ========================================
const MORPH_RESOLUTION = 24;

let morphCurrentShapeRaw = null;
let morphCurrentShape = null;
let morphNextShape = null;
let morphCurrentN = 3;
let morphStartTime = 0;
let morphPhase = 'hold'; // 'hold' or 'morph'
let morphHoldStartTime = 0;
let morphCurrentRotation = 0;
let morphAnimRunning = false;

function morphPickNextN() {
  const min = morphConfig.verticesMin;
  const max = morphConfig.verticesMax;
  let n;
  do {
    n = min + Math.floor(Math.random() * (max - min + 1));
  } while (n === morphCurrentN && max > min);
  return n;
}

function morphMakeRawShape(n) {
  const raw = generatePolygon(n, morphConfig.irregularity);
  return normalizeArea(raw, TARGET_AREA);
}

function morphStartNew() {
  const nextN = morphPickNextN();

  if (!morphCurrentShapeRaw) {
    morphCurrentShapeRaw = morphMakeRawShape(morphCurrentN);
  }

  const nextShapeRaw = morphMakeRawShape(nextN);
  morphCurrentShape = resamplePolygon(morphCurrentShapeRaw, MORPH_RESOLUTION);
  const nextResampled = resamplePolygon(nextShapeRaw, MORPH_RESOLUTION);
  morphNextShape = findBestRotation(morphCurrentShape, nextResampled);

  morphCurrentShapeRaw = nextShapeRaw;
  morphCurrentN = nextN;
  morphStartTime = performance.now();
  morphPhase = 'morph';
}

function morphApplyClipPath(clipPath, transform) {
  const el = state.currentCaret;
  if (!el || !el.classList.contains('thinking')) return;
  el.style.clipPath = clipPath;
  el.style.transform = transform;
}

function morphAnimationLoop(time) {
  if (!morphAnimRunning) return;

  if (morphPhase === 'hold') {
    const holdElapsed = time - morphHoldStartTime;

    if (morphConfig.holdRotation !== 0) {
      const holdDeg = morphCurrentRotation + (holdElapsed / 1000) * morphConfig.holdRotation;
      const clipPath = toClipPath(morphCurrentShapeRaw);
      morphApplyClipPath(clipPath, `scale(1) rotate(${holdDeg.toFixed(1)}deg)`);
    }

    if (holdElapsed >= morphConfig.holdDuration) {
      if (morphConfig.holdRotation !== 0) {
        morphCurrentRotation += (morphConfig.holdDuration / 1000) * morphConfig.holdRotation;
        morphCurrentRotation = morphCurrentRotation % 360;
      }
      morphStartNew();
    }
  }

  if (morphPhase === 'morph') {
    const elapsed = time - morphStartTime;
    const rawT = Math.min(1, elapsed / morphConfig.morphDuration);
    const t = getMorphEasing(rawT);

    const interpolated = lerpPolygons(morphCurrentShape, morphNextShape, t);
    const clipPath = toClipPath(interpolated);

    const scaleFactor = 1 + (morphConfig.scalePulse - 1) * Math.sin(rawT * Math.PI);
    const rotationDelta = morphConfig.rotation * rawT;

    morphApplyClipPath(clipPath, `scale(${scaleFactor.toFixed(3)}) rotate(${(morphCurrentRotation + rotationDelta).toFixed(1)}deg)`);

    if (rawT >= 1) {
      morphCurrentRotation = (morphCurrentRotation + morphConfig.rotation) % 360;
      morphPhase = 'hold';
      morphHoldStartTime = time;

      const holdClip = toClipPath(morphCurrentShapeRaw);
      morphApplyClipPath(holdClip, `scale(1) rotate(${morphCurrentRotation.toFixed(1)}deg)`);
    }
  }

  requestAnimationFrame(morphAnimationLoop);
}

function startMorphAnimation() {
  if (morphAnimRunning) return;
  morphCurrentShapeRaw = morphMakeRawShape(morphConfig.verticesMin);
  morphCurrentN = morphConfig.verticesMin;
  morphPhase = 'hold';
  morphHoldStartTime = performance.now();
  morphAnimRunning = true;

  // 初期clip-pathを適用
  const initClip = toClipPath(morphCurrentShapeRaw);
  morphApplyClipPath(initClip, 'scale(1) rotate(0deg)');

  requestAnimationFrame(morphAnimationLoop);
}

function stopMorphAnimation() {
  morphAnimRunning = false;
}

// ========================================
// 多角形 ↔ 縦棒 トランジション
// ========================================
let caretTransPhase = 'none'; // 'none', 'to-bar', 'to-polygon'
let caretTransStartTime = 0;
let caretTransFromShape = null;
let caretTransToShape = null;

function startCaretTransitionToBar() {
  if (!morphCurrentShapeRaw) return;
  stopMorphAnimation();

  const barShape = getBarShape();
  caretTransFromShape = resamplePolygon(morphCurrentShapeRaw, MORPH_RESOLUTION);
  const barResampled = resamplePolygon(barShape, MORPH_RESOLUTION);
  caretTransToShape = findBestRotation(caretTransFromShape, barResampled);
  caretTransStartTime = performance.now();
  caretTransPhase = 'to-bar';

  requestAnimationFrame(caretTransitionLoop);
}

function startCaretTransitionToPolygon() {
  morphCurrentShapeRaw = morphMakeRawShape(
    morphConfig.verticesMin + Math.floor(Math.random() * (morphConfig.verticesMax - morphConfig.verticesMin + 1))
  );
  morphCurrentN = morphConfig.verticesMin;

  const barShape = getBarShape();
  caretTransFromShape = resamplePolygon(barShape, MORPH_RESOLUTION);
  const polyResampled = resamplePolygon(morphCurrentShapeRaw, MORPH_RESOLUTION);
  caretTransToShape = findBestRotation(caretTransFromShape, polyResampled);
  caretTransStartTime = performance.now();
  caretTransPhase = 'to-polygon';

  requestAnimationFrame(caretTransitionLoop);
}

function caretTransitionLoop(time) {
  if (caretTransPhase === 'none') return;

  const el = state.currentCaret;
  if (!el) {
    caretTransPhase = 'none';
    return;
  }

  const elapsed = time - caretTransStartTime;
  const rawT = Math.min(1, elapsed / morphConfig.toBarDuration);
  const easingFn = easings[morphConfig.toBarEasing] || easings['ease-out'];
  const t = easingFn(rawT);
  const interpolated = lerpPolygons(caretTransFromShape, caretTransToShape, t);
  const fullSize = morphConfig.size;
  const barPx = getBarPixelWidth();

  if (caretTransPhase === 'to-bar') {
    // clip-path: 形のモーフ
    el.style.clipPath = toClipPath(interpolated);
    el.style.transform = 'scale(1)';

    // width: rawT^3 で遅延（形が先行、幅が後追い）
    const widthT = Math.pow(rawT, 3);
    const w = fullSize + (barPx - fullSize) * widthT;
    el.style.width = w + 'px';

    if (rawT >= 1) {
      caretTransPhase = 'none';
      // 最終状態：barクリップ + bar幅
      el.style.clipPath = getFullWidthBarClipPath();
      el.style.width = barPx + 'px';
      el.style.height = '1em';
      el.style.verticalAlign = '-4px';
      el.classList.remove('thinking');
    }
  }

  if (caretTransPhase === 'to-polygon') {
    el.style.clipPath = toClipPath(interpolated);
    el.style.transform = 'scale(1)';

    // width: 1-(1-rawT)^3 で先行拡大
    const widthT = 1 - Math.pow(1 - rawT, 3);
    const w = barPx + (fullSize - barPx) * widthT;
    el.style.width = w + 'px';
    el.style.height = fullSize + 'px';
    el.style.verticalAlign = 'middle';

    if (rawT >= 1) {
      caretTransPhase = 'none';
      el.style.clipPath = toClipPath(morphCurrentShapeRaw);
      el.style.width = fullSize + 'px';
      el.style.height = fullSize + 'px';
      el.style.verticalAlign = 'middle';
      // 多角形morphループを再開
      startMorphAnimation();
    }
  }

  if (caretTransPhase !== 'none') {
    requestAnimationFrame(caretTransitionLoop);
  }
}

// ========================================
// キャレット制御
// ========================================
function showThinkingCaret() {
  removeCurrentCaret();
  const caret = document.createElement('span');
  caret.className = 'caret thinking generating';
  caret.style.setProperty('width', morphConfig.size + 'px');
  caret.style.setProperty('height', morphConfig.size + 'px');
  if (state.currentJaElement) {
    state.currentJaElement.appendChild(caret);
  }
  state.currentCaret = caret;
  // 多角形モーフ開始
  startMorphAnimation();
}

function removeCurrentCaret() {
  stopMorphAnimation();
  caretTransPhase = 'none';
  if (state.currentCaret && state.currentCaret.parentNode) {
    state.currentCaret.remove();
  }
  state.currentCaret = null;
}

function transformCaretToBar() {
  if (state.currentCaret && state.currentCaret.classList.contains('thinking')) {
    startCaretTransitionToBar();
  }
}

function transformCaretToThinking() {
  if (state.currentCaret) {
    state.currentCaret.classList.add('thinking');
    // barスタイルをリセットして多角形サイズに
    state.currentCaret.style.width = morphConfig.size + 'px';
    state.currentCaret.style.height = morphConfig.size + 'px';
    state.currentCaret.style.verticalAlign = 'middle';
    startCaretTransitionToPolygon();
  }
}

// ========================================
// 初期表示（#1〜#8 + #9の最初のブレークポイント）
// ========================================
function findSegmentIndexForRule(ruleNum, position) {
  // 指定ルール番号の最初/最後のセグメントインデックスを返す
  let firstIndex = -1;
  let lastIndex = -1;

  for (let i = 0; i < state.segments.length; i++) {
    if (Number(state.segments[i].num) === Number(ruleNum)) {
      if (firstIndex === -1) firstIndex = i;
      lastIndex = i;
    }
  }

  return position === 'first' ? firstIndex : lastIndex;
}

function findNextBreakpointIndex(startIndex) {
  // 指定インデックスから次のブレークポイント（「、」で終わるセグメント）を探す
  for (let i = startIndex; i < state.segments.length; i++) {
    if (state.segments[i].jaSegment.endsWith('、')) {
      return i;
    }
  }
  return state.segments.length - 1; // 見つからなければ最後まで
}

function displayInitialRules() {
  // 開始ルール番号を取得（URLパラメータまたはリモート設定）
  const startRule = CONFIG.startRule;

  // 開始ルールの最後のセグメントを取得
  const ruleEnd = findSegmentIndexForRule(startRule, 'last');

  if (ruleEnd === -1) {
    console.warn(`Rule #${startRule} not found in ${state.segments.length} segments, starting from beginning`);
    // フォールバック：先頭のブレークポイントまで表示
    if (state.segments.length === 0) return;
  }

  // 次のルールの最初のブレークポイントまで表示
  const initialEndIndex = ruleEnd === -1
    ? findNextBreakpointIndex(0)
    : findNextBreakpointIndex(ruleEnd + 1);

  for (let i = 0; i <= initialEndIndex; i++) {
    const segment = state.segments[i];

    // 新しいルール番号なら要素を作成
    if (segment.isFirst) {
      const { numberElement, jaElement, enElement } = createRuleElement(segment.num);
      state.currentNumberElement = numberElement;
      state.currentJaElement = jaElement;
      state.currentEnElement = enElement;

      // 初期表示なので番号を即座に設定
      numberElement.textContent = `#${segment.num}`;

      // 開始ルール以下は黒、それ以降はグレー
      if (Number(segment.num) <= Number(startRule)) {
        numberElement.classList.remove('generating');
        jaElement.classList.remove('generating');
        enElement.classList.remove('generating');
      }

      // 内容物・じゃんけんの手を即時表示
      if (segment.componentJa) {
        addComponentInstant(segment.componentJa, segment.componentEn);
      }
      if (segment.jankenJa) {
        addHandInstant(segment.jankenJa, segment.jankenEn);
      }
    }

    // 日本語テキストを追加（タイプライターなし）
    const textNode = document.createTextNode(segment.jaSegment);
    state.currentJaElement.appendChild(textNode);

    // ルールの最後なら英語も表示
    if (segment.isLast && segment.enFull) {
      state.currentEnElement.textContent = segment.enFull;
      // 英語表示後、ルールを黒に
      state.currentNumberElement.classList.remove('generating');
      state.currentJaElement.classList.remove('generating');
    }
  }

  // 次のセグメントインデックスを設定
  state.currentSegmentIndex = initialEndIndex + 1;

  // 最後のセグメントにキャレットを表示
  showThinkingCaret();

  // スクロール位置を最下部に
  setTimeout(() => {
    scrollToBottom();
  }, 100);

  // ページタイトル更新
  updatePageTitle();

  // 表示済みルールまでのバージョンを計算
  const lastDisplayedNum = state.segments[initialEndIndex]?.num;
  if (lastDisplayedNum) {
    const ver = calculateVersion(state.rules, lastDisplayedNum);
    updateVersionDisplay(ver.major, ver.minor, false);
  }

  console.log(`Initial display complete. Next segment index: ${state.currentSegmentIndex}`);
}

// ========================================
// ブレークポイント生成
// ========================================

// 次のブレークポイントまで生成するセグメントを計算
function calculateSegmentsToGenerate() {
  const segments = [];
  let totalChars = 0;
  let i = state.currentSegmentIndex;
  let foundBreakpointInNextRule = false;

  while (i < state.segments.length && !foundBreakpointInNextRule) {
    const seg = state.segments[i];
    segments.push({ ...seg, index: i });
    totalChars += seg.jaSegment.length;

    if (seg.isLast && seg.enFull) {
      totalChars += seg.enFull.length;
    }

    // 次のルールのブレークポイントで停止
    if (seg.isLast) {
      // 現在のルールが終了、次のルールへ
      i++;
      while (i < state.segments.length) {
        const nextSeg = state.segments[i];
        segments.push({ ...nextSeg, index: i });
        totalChars += nextSeg.jaSegment.length;

        if (nextSeg.jaSegment.endsWith('、')) {
          foundBreakpointInNextRule = true;
          break;
        }

        if (nextSeg.isLast && nextSeg.enFull) {
          totalChars += nextSeg.enFull.length;
        }
        i++;
      }
      break;
    }
    i++;
  }

  return { segments, totalChars };
}

// メイン生成関数：次のブレークポイントまで生成
// trigger: 'manual'（ボタン）, 'auto'（タイマー）
async function generateUntilNextBreakpoint(trigger = 'manual') {
  clearAutoGenerateTimer();
  if (state.isGenerating || state.isThinking) return;
  if (state.isPaused) {
    console.log('Generation paused by remote config');
    return;
  }
  if (state.currentSegmentIndex >= state.segments.length) {
    console.log('No more segments to display');
    return;
  }

  // 前回のハイライトを解除
  removeLeftPanelHighlights();

  // トリガー種別をログ送信
  reportStatus(trigger === 'auto' ? '自動更新' : '手動更新');

  state.isGenerating = true;
  state.isThinking = false;
  updateButtonState();  // transitionButton('generating') を発火
  updatePageTitle();

  // ボタンモーション完了を待ってからテキスト生成開始
  await waitForButtonTransition();

  // ボタン押下時に最下部へスクロール＆自動スクロール有効化
  state.isAutoScroll = true;
  scrollToBottom();

  // 生成するセグメントと総文字数を計算
  const { segments: segmentsToGenerate, totalChars } = calculateSegmentsToGenerate();
  console.log(`Total chars: ${totalChars}`);

  // バージョン更新（ボタン押下時に即反映）
  const lastSegInBatch = segmentsToGenerate[segmentsToGenerate.length - 1];
  if (lastSegInBatch) {
    const ver = calculateVersion(state.rules, lastSegInBatch.num);
    updateVersionDisplay(ver.major, ver.minor);
  }

  // ゲージタイマー開始（モーション完了後に増加開始）
  startGaugeTimer();

  // ●キャレットを｜に変化
  transformCaretToBar();

  let charsDone = 0;

  for (const seg of segmentsToGenerate) {
    // 新しいルール番号なら要素を作成
    if (seg.isFirst) {
      const { ruleElement, numberElement, jaElement, enElement } = createRuleElement(seg.num);
      state.currentRuleElement = ruleElement;
      state.currentNumberElement = numberElement;
      state.currentJaElement = jaElement;
      state.currentEnElement = enElement;
      // 新規ルールの場合はキャレットも新規作成
      removeCurrentCaret();
      // 新しいルール要素が見えるようにスクロール
      if (state.isAutoScroll) {
        scrollToBottom();
      }
      // 番号をタイプライター表示
      await typewriterNumber(seg.num);

      // 内容物・じゃんけんの手データを一時保持（ルール完了後に表示する）
      if (seg.componentJa) {
        state.pendingComponent = { ja: seg.componentJa, en: seg.componentEn };
      }
      if (seg.jankenJa) {
        state.pendingHands = { ja: seg.jankenJa, en: seg.jankenEn };
      }
    }

    // 日本語タイプライター（統合進捗）
    await typewriterJaWithProgress(seg.jaSegment, charsDone, totalChars, seg.isFirst);
    charsDone += seg.jaSegment.length;

    // ルールの最後なら英語をタイプライター表示
    if (seg.isLast && seg.enFull) {
      removeCurrentCaret();
      await typewriterEnWithProgress(seg.enFull, charsDone, totalChars);
      charsDone += seg.enFull.length;
      // じわっと黒にフェード
      makeCurrentRuleBlack();
      // アニメーション完了を待つ（英語→次の番号への間）
      await delay(state.pauseEnToNum * 100);
    }

    // ルール完了後に左カラム表示を発火（右パネルと並行）
    if (seg.isLast) {
      if (state.pendingComponent) {
        queueLeftPanelTypewriter('component', state.pendingComponent.ja, state.pendingComponent.en);
        state.pendingComponent = null;
      }
      if (state.pendingHands) {
        queueLeftPanelTypewriter('hands', state.pendingHands.ja, state.pendingHands.en);
        state.pendingHands = null;
      }
    }

    state.currentSegmentIndex++;
  }

  // 最後のセグメントが「、」で終わるなら●に変化
  const lastSeg = segmentsToGenerate[segmentsToGenerate.length - 1];
  if (lastSeg && lastSeg.jaSegment.endsWith('、')) {
    transformCaretToThinking();
  }

  // 文字出力完了を通知（ゲージがまだなら思考中状態へ）
  onTextComplete();

  if (state.isAutoScroll) {
    scrollToBottom();
  }
}

// 日本語タイプライター（統合進捗付き）
async function typewriterJaWithProgress(text, baseChars, totalChars, isNewRule = false) {
  // キャレットがなければ作成
  if (!state.currentCaret) {
    const caret = document.createElement('span');
    caret.className = 'caret generating';
    state.currentJaElement.appendChild(caret);
    state.currentCaret = caret;
  }

  // 番号 → 日本語の切り替え待機
  if (isNewRule) {
    await delay(getTypewriterDelay() * state.pauseNumToJa);
  }

  for (let i = 0; i < text.length; i++) {
    const char = text[i];

    // たまにタイポ（確率設定可能、句読点や括弧では発生しない）
    const isPunctuation = '。、．，「」『』（）()'.includes(char);
    if (!isPunctuation && Math.random() < state.typoChance) {
      // 間違った文字を入力
      const typoChar = getRandomTypoChar();
      const typoNode = document.createTextNode(typoChar);
      if (state.currentCaret && state.currentCaret.parentNode) {
        state.currentCaret.parentNode.insertBefore(typoNode, state.currentCaret);
      }
      if (state.isAutoScroll) scrollToBottom();
      await delay(getTypewriterDelay() * 0.8);

      // 一瞬止まる（気づく）
      await delay(getTypewriterDelay() * state.typoPause);

      // バックスペース（削除）
      if (typoNode.parentNode) {
        typoNode.remove();
      }
      if (state.isAutoScroll) scrollToBottom();
      await delay(getTypewriterDelay() * 0.5);
    }

    // インク侵食用：spanでラップして黒で生成→じわっとグレーへ
    const charSpan = document.createElement('span');
    charSpan.textContent = char;
    charSpan.style.color = '#000';

    // キャレットの前にテキストを挿入
    if (state.currentCaret && state.currentCaret.parentNode) {
      state.currentCaret.parentNode.insertBefore(charSpan, state.currentCaret);
    } else {
      state.currentJaElement.appendChild(charSpan);
    }

    // インク侵食登録
    inkFadeRegister(charSpan);

    // 統合進捗更新
    const progress = (baseChars + i + 1) / totalChars;
    updateProgressBar(progress);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    // 文字に応じた遅延
    await delay(getTypewriterDelay(char));
  }
}

// ランダムなタイポ文字を返す
function getRandomTypoChar() {
  const typoChars = 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん';
  return typoChars[Math.floor(Math.random() * typoChars.length)];
}

// 番号タイプライター（#nn）
async function typewriterNumber(num) {
  const text = `#${num}`;
  const caret = document.createElement('span');
  caret.className = 'caret generating';
  state.currentNumberElement.appendChild(caret);
  state.currentCaret = caret;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    // インク侵食用：spanでラップ
    const charSpan = document.createElement('span');
    charSpan.textContent = char;
    charSpan.style.color = '#000';
    caret.parentNode.insertBefore(charSpan, caret);

    // インク侵食登録
    inkFadeRegister(charSpan);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    await delay(getTypewriterDelay());
  }

  // キャレットを削除（日本語タイプライターで新しく作る）
  caret.remove();
  state.currentCaret = null;
}

// 英語タイプライター（統合進捗付き）
async function typewriterEnWithProgress(text, baseChars, totalChars) {
  // 日本語 → 英語の切り替え待機
  await delay(getTypewriterDelay() * state.pauseJaToEn);

  const caret = document.createElement('span');
  caret.className = 'caret';
  state.currentEnElement.appendChild(caret);

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    // インク侵食用：spanでラップ
    const charSpan = document.createElement('span');
    charSpan.textContent = char;
    charSpan.style.color = '#000';
    caret.parentNode.insertBefore(charSpan, caret);

    // インク侵食登録
    inkFadeRegister(charSpan);

    // 統合進捗更新
    const progress = (baseChars + i + 1) / totalChars;
    updateProgressBar(progress);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    // 文字に応じた遅延（英語用）
    await delay(getTypewriterDelayEn(char));
  }

  // 英語タイプライター終了後、キャレットを削除
  caret.remove();
}

// タイプライター速度計算（日本語用）
// 自然なゆらぎのある速度（1分縛りなし）
function getTypewriterDelay(char = '') {
  // 速度1: 約200ms, 速度100: 約10ms
  const speed = state.typewriterSpeed;
  const base = 200 * Math.pow(0.05, (speed - 1) / 99);

  // 句読点で少し考える時間を追加
  if (char === '。' || char === '．') {
    return base * state.pauseKuten;
  }
  if (char === '、' || char === '，') {
    return base * state.pauseTouten;
  }
  if (char === '「' || char === '『' || char === '(' || char === '（') {
    return base * state.pauseOpenBracket;
  }
  if (char === '」' || char === '』' || char === ')' || char === '）') {
    return base * state.pauseCloseBracket;
  }

  // ランダム性を加える
  const randomFactor = 1 + (Math.random() - 0.5) * state.varianceJa * 2;
  return base * randomFactor;
}

// タイプライター速度計算（英語用）
// 日本語と同じ速度計算を使用
function getTypewriterDelayEn(char = '') {
  const speed = state.typewriterSpeed;
  const base = 200 * Math.pow(0.05, (speed - 1) / 99);

  // 英語の句読点
  if (char === '.') {
    return base * state.pausePeriod;
  }
  if (char === ',') {
    return base * state.pauseComma;
  }
  if (char === ' ') {
    return base * state.pauseSpace;
  }

  // ランダム性を加える
  const randomFactor = 1 + (Math.random() - 0.5) * state.varianceEn * 2;
  return base * randomFactor;
}

// ディレイユーティリティ
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// ========================================
// 進捗バー（時間基準：54秒で0→90%、残り10%で文字完了待ち）
// ========================================
let gaugeStartTime = null;
let gaugeAnimationFrame = null;
let textComplete = false;  // 文字出力が完了したか
let gaugePausedAt90 = false;  // 90%で一時停止中か
let currentPausePoint = 0.90;  // 今回の停止ポイント（ゆらぎ適用後）
let autoGenerateTimer = null;  // 自動更新タイマー

function startGaugeTimer() {
  gaugeStartTime = Date.now();
  textComplete = false;
  gaugePausedAt90 = false;
  lastGaugeProgress = 0;  // ゆらぎ用進捗をリセット

  // 停止ポイントにゆらぎを適用（毎回違う位置で止まる）
  const variance = (Math.random() * 2 - 1) * state.gaugePausePointVariance;
  currentPausePoint = Math.max(0.5, Math.min(0.99, state.gaugePausePoint + variance));

  animateGauge();
}

let lastGaugeProgress = 0;  // 前回の進捗を記憶（戻らないように）

function animateGauge() {
  if (!gaugeStartTime) return;

  const elapsed = Date.now() - gaugeStartTime;

  // 呼吸のような波で速度を変調（0〜1の範囲、負にならない）
  const wave = Math.sin(elapsed * state.gaugeWaveFrequency * 0.001 * Math.PI * 2);
  const speedMultiplier = 1 + wave * state.gaugeWaveAmplitude * 10;  // 0.85〜1.15程度
  const effectiveSpeed = Math.max(0, speedMultiplier);  // 負にならないように

  // 基本進捗に速度変調を適用（積分的に進む）
  const deltaTime = 16;  // 約60fps
  const progressIncrement = (deltaTime / state.gaugeDuration) * effectiveSpeed;
  let progress = Math.min(lastGaugeProgress + progressIncrement, currentPausePoint);

  // 進捗は常に増加のみ（戻らない）
  progress = Math.max(lastGaugeProgress, progress);
  lastGaugeProgress = progress;

  elements.progressFill.style.width = `${progress * 100}%`;

  if (progress < currentPausePoint) {
    // まだ停止ポイントに達していない
    gaugeAnimationFrame = requestAnimationFrame(animateGauge);
  } else {
    // 停止ポイントに達した
    if (textComplete) {
      // 文字も終わってる → 即座に100%へ
      finishGauge();
    } else {
      // 文字がまだ → 停止ポイントで一時停止（onTextCompleteで再開）
      gaugePausedAt90 = true;
    }
  }
}

function finishGauge() {
  // 停止時間にゆらぎを適用
  const durationVariance = (Math.random() * 2 - 1) * state.gaugePauseDurationVariance;
  const pauseDuration = Math.max(100, state.gaugePauseDuration * (1 + durationVariance));

  // 停止後 → 100% へスムーズにアニメーション
  setTimeout(() => {
    elements.progressFill.style.transition = 'width 0.5s ease-out';
    elements.progressFill.style.width = '100%';

    setTimeout(() => {
      elements.progressFill.style.transition = '';
      onGaugeComplete();
    }, 500);
  }, pauseDuration);
}

function onGaugeComplete() {
  gaugeAnimationFrame = null;
  gaugeStartTime = null;
  gaugePausedAt90 = false;

  // 思考中状態を解除
  state.isThinking = false;
  state.isGenerating = false;
  updateButtonState();
  updatePageTitle();
  reportStatus('待機中');

  // 自動更新タイマー開始
  startAutoGenerateTimer();
}

// ========================================
// 自動更新タイマー
// ========================================
let countdownScheduleTimers = []; // カウントダウン表示スケジュール用

function startAutoGenerateTimer() {
  clearAutoGenerateTimer();
  if (state.autoGenerateDelay <= 0) return;  // 0以下なら無効

  const delayMs = state.autoGenerateDelay;
  const delaySec = delayMs / 1000;

  // カウントダウン表示スケジュール：残り2:30、2:00、1:30、1:00、0:10 で10秒間表示
  const countdownTriggers = [150, 120, 90, 60, 10]; // 秒
  countdownTriggers.forEach(triggerSec => {
    if (delaySec > triggerSec) {
      const showAt = delayMs - triggerSec * 1000; // トリガーまでのms
      const timer = setTimeout(() => {
        if (!state.isGenerating && !state.isThinking && !state.isPaused) {
          showCountdown(triggerSec);
        }
      }, showAt);
      countdownScheduleTimers.push(timer);
    }
  });

  autoGenerateTimer = setTimeout(() => {
    clearCountdown();
    if (!state.isGenerating && !state.isThinking && !state.isPaused) {
      generateUntilNextBreakpoint('auto');
    }
  }, delayMs);
}

function clearAutoGenerateTimer() {
  if (autoGenerateTimer) {
    clearTimeout(autoGenerateTimer);
    autoGenerateTimer = null;
  }
  // カウントダウンスケジュールもクリア
  countdownScheduleTimers.forEach(t => clearTimeout(t));
  countdownScheduleTimers = [];
  clearCountdown();
}

function onTextComplete() {
  textComplete = true;

  if (gaugePausedAt90) {
    // ゲージが90%で待っていた → 100%へ
    finishGauge();
  } else if (gaugeStartTime) {
    // ゲージがまだ動いている → 思考中状態へ
    state.isThinking = true;
    updateButtonState();
  }
  // ゲージが既に完了済み（gaugeStartTime === null）なら何もしない
}

function resetProgressBar() {
  if (gaugeAnimationFrame) {
    cancelAnimationFrame(gaugeAnimationFrame);
    gaugeAnimationFrame = null;
  }
  gaugeStartTime = null;
  textComplete = false;
  gaugePausedAt90 = false;
  lastGaugeProgress = 0;  // ゆらぎ用進捗もリセット
  elements.progressFill.style.transition = '';
  elements.progressFill.style.width = '0%';
}

// ドレインアニメーション（Promise返却、await可能）
function drainProgressBar() {
  return new Promise(resolve => {
    const drainMs = state.gaugeDrainDuration;
    const easing = state.gaugeDrainEasing;
    elements.progressFill.style.transition = `width ${drainMs}ms ${easing}`;
    elements.progressFill.style.width = '0%';
    setTimeout(() => {
      elements.progressFill.style.transition = '';
      resolve();
    }, drainMs);
  });
}

// 旧APIとの互換性（呼び出し箇所では何もしない）
function updateProgressBar(progress) {
  // 文字進捗は無視（ゲージは時間基準）
}

// ========================================
// ボタンモーション設定
// ========================================
const buttonMotion = {
  distance: 16,
  outDuration: 280,
  inDuration: 280,
  stagger: 65,
  gap: 140,
  outEasing: 'ease-in',
  inEasing: 'ease-out',
  exitDirection: 'down',
  enterDirection: 'up',
  jaFirst: false,  // 退場はEN先行（スクリーンショットの設定）、登場は常にJA先行
};

// ボタン状態名
const BUTTON_STATES = {
  idle:       { ja: '続きを生成',          en: 'Continue Generating',    isIdle: true,  countdown: false },
  countdown:  { ja: '自動生成まであと{time}', en: 'Auto-generate in {time}', isIdle: true,  countdown: true  },
  generating: { ja: 'ルール生成中...',      en: 'Generating Rules...',     isIdle: false, countdown: false },
  thinking:   { ja: '次のルールを思考中...', en: 'Thinking...',            isIdle: false, countdown: false },
};

let currentButtonState = 'idle';
let buttonAnimating = false;
let pendingButtonState = null; // アニメ中にリクエストされた次の状態
let buttonTransitionResolve = null; // transitionButton完了通知用

// ボタンモーション完了を待つ（generateUntilNextBreakpoint等で使用）
function waitForButtonTransition() {
  return new Promise(resolve => {
    if (!buttonAnimating) { resolve(); return; }
    buttonTransitionResolve = resolve;
  });
}

// 簡易イージング
const btnEasings = {
  'ease-in':  t => t * t,
  'ease-out': t => 1 - (1 - t) * (1 - t),
  'linear':   t => t,
};

function btnDirectionVec(dir, dist) {
  switch (dir) {
    case 'up':    return { x: 0, y: -dist };
    case 'down':  return { x: 0, y: dist };
    case 'left':  return { x: -dist, y: 0 };
    case 'right': return { x: dist, y: 0 };
    default:      return { x: 0, y: dist };
  }
}

function btnAnimate(el, params) {
  return new Promise(resolve => {
    const start = performance.now();
    const { fromX = 0, toX = 0, fromY = 0, toY = 0, fromOpacity, toOpacity, duration, easing } = params;
    const easingFn = btnEasings[easing] || btnEasings['linear'];
    function loop(now) {
      const rawT = Math.min(1, (now - start) / duration);
      const t = easingFn(rawT);
      el.style.transform = `translate(${fromX + (toX - fromX) * t}px, ${fromY + (toY - fromY) * t}px)`;
      el.style.opacity = fromOpacity + (toOpacity - fromOpacity) * t;
      if (rawT < 1) requestAnimationFrame(loop);
      else resolve();
    }
    requestAnimationFrame(loop);
  });
}

function btnWait(ms) { return new Promise(r => setTimeout(r, ms)); }

async function transitionButton(newStateName) {
  if (newStateName === currentButtonState && !buttonAnimating) return;
  if (buttonAnimating) {
    pendingButtonState = newStateName; // 最新のリクエストを保持
    return;
  }
  buttonAnimating = true;

  const button = elements.actionButton;
  const btnContainer = elements.actionButtonContainer;
  const btnJa = button.querySelector('.button-ja');
  const btnEn = button.querySelector('.button-en');
  const toState = BUTTON_STATES[newStateName];
  const dist = buttonMotion.distance;
  const exitVec = btnDirectionVec(buttonMotion.exitDirection, dist);
  const enterVec = btnDirectionVec(buttonMotion.enterDirection, dist);

  // ---- EXIT ----
  const exitFirst = buttonMotion.jaFirst ? btnJa : btnEn;
  const exitSecond = buttonMotion.jaFirst ? btnEn : btnJa;
  const wasIdle = BUTTON_STATES[currentButtonState]?.isIdle;

  const exitP1 = btnAnimate(exitFirst, {
    toX: exitVec.x, toY: exitVec.y,
    fromOpacity: 1, toOpacity: 0,
    duration: buttonMotion.outDuration,
    easing: buttonMotion.outEasing,
  });
  await btnWait(buttonMotion.stagger);
  const exitP2 = btnAnimate(exitSecond, {
    toX: exitVec.x, toY: exitVec.y,
    fromOpacity: 1, toOpacity: 0,
    duration: buttonMotion.outDuration,
    easing: buttonMotion.outEasing,
  });
  await exitP1;
  await exitP2;

  // ---- テキスト差し替え ----
  if (toState.countdown) {
    const timeStr = formatCountdown(countdownRemaining);
    btnJa.innerHTML = toState.ja.replace('{time}',
      `<span class="countdown-time" id="cd-ja">${timeStr}</span>`);
    btnEn.innerHTML = toState.en.replace('{time}',
      `<span class="countdown-time" id="cd-en">${timeStr}</span>`);
  } else {
    btnJa.textContent = toState.ja;
    btnEn.textContent = toState.en;
  }

  // ---- クラス切り替え＋ドレイン（直列）----
  if (wasIdle && !toState.isIdle) {
    // idle → generating: fill=100%で黒を維持→.idle除去→ドレインで白を露出
    elements.progressFill.style.transition = '';
    elements.progressFill.style.width = '100%';
    void elements.progressFill.offsetWidth;  // 強制リフロー
    btnContainer.classList.remove('idle');
    btnContainer.classList.add('generating');
    button.classList.add('generating');
    await drainProgressBar();
  } else if (!wasIdle && toState.isIdle) {
    // generating → idle: .idle先付けで背景黒→ドレインでfill除去
    btnContainer.classList.add('idle');
    btnContainer.classList.remove('generating');
    button.classList.remove('generating');
    // fillが100%でなければ100%にセット（transitionなしで即座に）
    elements.progressFill.style.transition = '';
    const currentWidth = parseFloat(elements.progressFill.style.width) || 0;
    if (currentWidth < 100) {
      elements.progressFill.style.width = '100%';
      void elements.progressFill.offsetWidth;
    }
    await drainProgressBar();
    // ゲージ状態をクリーンアップ
    textComplete = false;
    lastGaugeProgress = 0;
  } else if (toState.isIdle) {
    button.classList.remove('generating');
    btnContainer.classList.remove('generating');
    btnContainer.classList.add('idle');
  } else {
    button.classList.add('generating');
    btnContainer.classList.add('generating');
    btnContainer.classList.remove('idle');
  }

  // 初期位置
  btnJa.style.transform = `translate(${-enterVec.x}px, ${-enterVec.y}px)`;
  btnJa.style.opacity = '0';
  btnEn.style.transform = `translate(${-enterVec.x}px, ${-enterVec.y}px)`;
  btnEn.style.opacity = '0';

  await btnWait(buttonMotion.gap);

  // ---- ENTER（常にJA先行）----
  const enterP1 = btnAnimate(btnJa, {
    fromX: -enterVec.x, fromY: -enterVec.y,
    fromOpacity: 0, toOpacity: 1,
    duration: buttonMotion.inDuration,
    easing: buttonMotion.inEasing,
  });
  await btnWait(buttonMotion.stagger);
  const enterP2 = btnAnimate(btnEn, {
    fromX: -enterVec.x, fromY: -enterVec.y,
    fromOpacity: 0, toOpacity: 1,
    duration: buttonMotion.inDuration,
    easing: buttonMotion.inEasing,
  });
  await enterP1;
  await enterP2;

  // クリーンアップ
  btnJa.style.transform = '';
  btnJa.style.opacity = '';
  btnEn.style.transform = '';
  btnEn.style.opacity = '';

  currentButtonState = newStateName;
  buttonAnimating = false;

  // 完了通知（waitForButtonTransition() の resolve）
  if (buttonTransitionResolve) {
    const r = buttonTransitionResolve;
    buttonTransitionResolve = null;
    r();
  }

  // アニメ中に別のリクエストが来ていた場合、続けて処理
  if (pendingButtonState && pendingButtonState !== currentButtonState) {
    const next = pendingButtonState;
    pendingButtonState = null;
    transitionButton(next);
  } else {
    pendingButtonState = null;
  }
}

// ========================================
// カウントダウン表示
// ========================================
let countdownRemaining = 0;  // 残り秒数
let countdownInterval = null;
let countdownShowTimer = null; // 表示期間管理

function formatCountdown(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${String(s).padStart(2, '0')}`;
}

function updateCountdownDisplay() {
  const timeStr = formatCountdown(Math.max(0, countdownRemaining));
  const ja = document.getElementById('cd-ja');
  const en = document.getElementById('cd-en');
  if (ja) ja.textContent = timeStr;
  if (en) en.textContent = timeStr;
}

function showCountdown(startSeconds) {
  countdownRemaining = startSeconds;
  // countdown状態に遷移
  transitionButton('countdown');
  // 1秒ごとにカウントダウン
  clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    countdownRemaining--;
    updateCountdownDisplay();
  }, 1000);
  // 10秒後にidle状態に戻す
  clearTimeout(countdownShowTimer);
  countdownShowTimer = setTimeout(() => {
    hideCountdown();
  }, 10000);
}

function hideCountdown() {
  clearInterval(countdownInterval);
  countdownInterval = null;
  clearTimeout(countdownShowTimer);
  countdownShowTimer = null;
  if (currentButtonState === 'countdown') {
    transitionButton('idle');
  }
}

function clearCountdown() {
  clearInterval(countdownInterval);
  countdownInterval = null;
  clearTimeout(countdownShowTimer);
  countdownShowTimer = null;
}

// ========================================
// ボタン状態
// ========================================
function updateButtonState() {
  const button = elements.actionButton;
  const container = elements.actionButtonContainer;

  // カウントダウン表示中に生成が始まったらカウントダウンをクリア
  clearCountdown();

  let targetState;
  if (state.isThinking) {
    targetState = 'thinking';
  } else if (state.isGenerating) {
    targetState = 'generating';
  } else {
    targetState = 'idle';
    // resetProgressBarはここで呼ばない
    // transitionButton内のドレインがfill 100%→0%を処理する
    // 先にfillを0%にすると白い明滅が発生する
  }

  // アニメーション付き遷移
  transitionButton(targetState);

  if (state.currentSegmentIndex >= state.segments.length) {
    button.disabled = true;
  }
}

// ========================================
// スクロール制御
// ========================================
function scrollToBottom() {
  elements.ruleList.scrollTo({
    top: elements.ruleList.scrollHeight,
    behavior: 'smooth',
  });
}

function checkScrollPosition() {
  const list = elements.ruleList;
  const isAtBottom = list.scrollHeight - list.scrollTop - list.clientHeight < 50;
  state.isAutoScroll = isAtBottom;
}

// ========================================
// イベントリスナー
// ========================================
function setupEventListeners() {
  // ボタンコンテナ全体をクリック可能に
  elements.actionButtonContainer.addEventListener('click', generateUntilNextBreakpoint);

  // 展示用：コンテキストメニュー無効化
  document.addEventListener('contextmenu', (e) => e.preventDefault());

  elements.ruleList.addEventListener('scroll', checkScrollPosition);

  // タイトル5回タップでデバッグモード有効化
  const gameTitle = document.querySelector('.game-title');
  if (gameTitle) {
    gameTitle.addEventListener('click', () => {
      titleTapCount++;

      // タイマーリセット（2秒以内に5回タップ）
      if (titleTapTimer) clearTimeout(titleTapTimer);
      titleTapTimer = setTimeout(() => {
        titleTapCount = 0;
      }, 2000);

      // 5回タップでデバッグモード有効化
      if (titleTapCount >= 5) {
        titleTapCount = 0;
        if (!isDebugMode) {
          isDebugMode = true;
          setupDebugPanel();
        }
      }
    });
  }
}

// ========================================
// 開発用：速度調整
// ========================================
window.setTypewriterSpeed = function(speed) {
  state.typewriterSpeed = Math.max(1, Math.min(100, speed));
  console.log(`Typewriter speed set to: ${state.typewriterSpeed}`);
};

window.getTypewriterSpeed = function() {
  return state.typewriterSpeed;
};

// デバッグ用
window.getState = function() {
  return state;
};

// ========================================
// リモート設定（ルールシートのconfig列から取得）
// ========================================
function startRemoteConfigPolling() {
  // 1分ごとにルールシートからリモート設定を確認
  setInterval(async () => {
    try {
      const data = await fetchSheetData(CONFIG.rulesSheetId);
      const rows = data.table.rows;
      if (!rows || rows.length === 0) return;

      const firstRow = rows[0].c;
      if (!firstRow) return;

      const config = {};
      if (firstRow[11]?.v !== undefined && firstRow[11]?.v !== null) {
        config.startRule = firstRow[11].v;
      }
      if (firstRow[12]?.v !== undefined && firstRow[12]?.v !== null) {
        config.isPaused = firstRow[12].v;
      }
      state.remoteConfig = config;

      // 一時停止フラグの確認
      const isPaused = config.isPaused === true || config.isPaused === 'true' || config.isPaused === 'TRUE';
      if (isPaused && !state.isPaused) {
        console.log('Remote pause activated');
        state.isPaused = true;
        state.isGenerating = false;
        updatePageTitle();
        reportStatus('停止中');
      } else if (!isPaused && state.isPaused) {
        console.log('Remote pause deactivated');
        state.isPaused = false;
        updatePageTitle();
        reportStatus('待機中');
      }

      // 開始ルール番号の変更検知 → 自動リロード
      if (config.startRule !== undefined) {
        const newStartRule = parseInt(config.startRule);
        if (!isNaN(newStartRule) && newStartRule !== CONFIG.startRule) {
          console.log(`Start rule updated: ${CONFIG.startRule} -> ${newStartRule}, reloading...`);
          if (!new URLSearchParams(window.location.search).has('startRule')) {
            reportStatus('リモートリロード');
            location.reload();
            return;
          }
        }
      }
    } catch (e) {
      console.error('Remote config polling failed:', e);
    }
  }, 60000); // 1分間隔
}

// ========================================
// デバッグパネル
// ========================================

// エクスポート可能な設定キー
const EXPORTABLE_KEYS = [
  'typewriterSpeed',
  'gaugeDuration',
  'gaugePausePoint',
  'gaugePausePointVariance',
  'gaugePauseDuration',
  'gaugePauseDurationVariance',
  'gaugeWaveAmplitude',
  'gaugeWaveFrequency',
  'autoGenerateDelay',
  'typoChance',
  'typoPause',
  'pauseNumToJa',
  'pauseJaToEn',
  'pauseEnToNum',
  'pauseKuten',
  'pauseTouten',
  'pauseOpenBracket',
  'pauseCloseBracket',
  'pausePeriod',
  'pauseComma',
  'pauseSpace',
  'varianceJa',
  'varianceEn',
];

// 設定をテキストにエクスポート
function exportSettings() {
  const settings = {};
  EXPORTABLE_KEYS.forEach(key => {
    settings[key] = state[key];
  });
  return JSON.stringify(settings, null, 2);
}

// テキストから設定をインポート
function importSettings(text) {
  try {
    const settings = JSON.parse(text);
    EXPORTABLE_KEYS.forEach(key => {
      if (settings[key] !== undefined) {
        state[key] = settings[key];
      }
    });
    // スライダーUIを更新
    refreshSliders();
    return true;
  } catch (e) {
    console.error('Import failed:', e);
    return false;
  }
}

// すべてのスライダーを現在のstate値で更新
function refreshSliders() {
  // setupSliderで登録した設定を再度反映
  const sliderConfigs = [
    { slider: 'speed-slider', value: 'speed-value', key: 'typewriterSpeed', scale: 1, toFixed: null },
    { slider: 'auto-generate-slider', value: 'auto-generate-value', key: 'autoGenerateDelay', scale: 1000, toFixed: null },
    { slider: 'gauge-duration-slider', value: 'gauge-duration-value', key: 'gaugeDuration', scale: 1000, toFixed: null },
  ];

  sliderConfigs.forEach(({ slider, value, key, scale, toFixed }) => {
    const sliderEl = document.getElementById(slider);
    const valueEl = document.getElementById(value);
    if (sliderEl && valueEl) {
      const displayValue = state[key] / scale;
      sliderEl.value = displayValue;
      valueEl.textContent = toFixed !== null ? displayValue.toFixed(toFixed) : displayValue;
    }
  });
}

// スライダー設定ヘルパー
function setupSlider(sliderId, valueId, stateKey, options = {}) {
  const { scale = 1, suffix = '', toFixed = null } = options;
  const slider = document.getElementById(sliderId);
  const valueEl = document.getElementById(valueId);
  if (!slider || !valueEl) return;

  // 初期値を設定
  const currentValue = state[stateKey] / scale;
  slider.value = currentValue;
  valueEl.textContent = toFixed !== null ? currentValue.toFixed(toFixed) : currentValue;

  // 入力時に更新
  slider.addEventListener('input', (e) => {
    const rawValue = parseFloat(e.target.value);
    state[stateKey] = rawValue * scale;
    valueEl.textContent = toFixed !== null ? rawValue.toFixed(toFixed) : rawValue;
  });
}

function setupDebugPanel() {
  if (!isDebugMode) return;

  const panel = document.getElementById('debug-panel');
  const resetBtn = document.getElementById('debug-reset');
  const closeBtn = document.getElementById('debug-close');
  const cacheClearBtn = document.getElementById('debug-cache-clear');

  if (!panel) return;

  panel.hidden = false;

  // バージョン表示
  const versionEl = document.getElementById('debug-version');
  if (versionEl) versionEl.textContent = VERSION;

  // 基本設定（Speed, Auto, Duration の3つのみ）
  setupSlider('speed-slider', 'speed-value', 'typewriterSpeed');
  setupSlider('auto-generate-slider', 'auto-generate-value', 'autoGenerateDelay', { scale: 1000 });
  setupSlider('gauge-duration-slider', 'gauge-duration-value', 'gaugeDuration', { scale: 1000 });

  // リセットボタン（シンプルにリロード）
  resetBtn.addEventListener('click', () => {
    location.reload();
  });

  // 閉じるボタン（パネルを非表示にするだけ）
  closeBtn.addEventListener('click', () => {
    panel.hidden = true;
    isDebugMode = false;
  });

  // キャッシュクリア＆リロードボタン
  cacheClearBtn.addEventListener('click', async () => {
    // Service Worker のキャッシュをクリア
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
    }
    // Service Worker を登録解除
    if ('serviceWorker' in navigator) {
      const registrations = await navigator.serviceWorker.getRegistrations();
      await Promise.all(registrations.map(reg => reg.unregister()));
    }
    // 強制リロード
    location.reload(true);
  });

  // 定期的に状態表示を更新
  setInterval(() => {
    const segmentEl = document.getElementById('debug-segment');
    const totalEl = document.getElementById('debug-total');
    const statusEl = document.getElementById('debug-status');

    if (segmentEl) segmentEl.textContent = state.currentSegmentIndex;
    if (totalEl) totalEl.textContent = state.segments.length;
    if (statusEl) {
      if (state.isPaused) {
        statusEl.textContent = '停止中';
      } else if (state.isThinking) {
        statusEl.textContent = '思考中';
      } else if (state.isGenerating) {
        statusEl.textContent = '生成中';
      } else {
        statusEl.textContent = '待機中';
      }
    }
  }, 500);

  // デバッグパネルのドラッグ機能
  const header = document.querySelector('.debug-header');
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  const startDrag = (clientX, clientY) => {
    isDragging = true;
    const rect = panel.getBoundingClientRect();
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    panel.style.transition = 'none';
  };

  const doDrag = (clientX, clientY) => {
    if (!isDragging) return;
    const x = clientX - dragOffsetX;
    const y = clientY - dragOffsetY;
    panel.style.left = `${Math.max(0, x)}px`;
    panel.style.top = `${Math.max(0, y)}px`;
    panel.style.bottom = 'auto';
    panel.style.right = 'auto';
  };

  const endDrag = () => {
    isDragging = false;
    panel.style.transition = '';
  };

  // マウスイベント
  header.addEventListener('mousedown', (e) => {
    startDrag(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', (e) => {
    doDrag(e.clientX, e.clientY);
  });
  document.addEventListener('mouseup', endDrag);

  // タッチイベント（iPad用）
  header.addEventListener('touchstart', (e) => {
    const touch = e.touches[0];
    startDrag(touch.clientX, touch.clientY);
  }, { passive: true });
  document.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    const touch = e.touches[0];
    doDrag(touch.clientX, touch.clientY);
  }, { passive: true });
  document.addEventListener('touchend', endDrag);
}

// ========================================
// 初期化
// ========================================
async function init() {
  console.log('Initializing app...');

  setupEventListeners();

  // ルールを読み込み（ルールシートにconfig列も含む）
  await loadRules();
  console.log(`Rules loaded: ${state.rules.length}, Segments: ${state.segments.length}`);

  // リモート設定を適用（URLパラメータがない場合）
  if (!new URLSearchParams(window.location.search).has('startRule')) {
    if (state.remoteConfig?.startRule !== undefined) {
      const startRule = parseInt(state.remoteConfig.startRule);
      if (!isNaN(startRule)) {
        CONFIG.startRule = startRule;
        console.log(`Start rule from remote config: ${startRule}`);
      }
    }
  }
  console.log(`CONFIG.startRule = ${CONFIG.startRule}`);

  // 初期ルールを表示
  displayInitialRules();

  // 初回の自動更新タイマー開始
  startAutoGenerateTimer();

  // デバッグパネルをセットアップ
  setupDebugPanel();

  // リモート設定の定期確認を開始
  startRemoteConfigPolling();

  // リロードログ送信
  reportStatus('リロード');

  console.log('App initialized');
}

document.addEventListener('DOMContentLoaded', init);
