/**
 * 完成しないゲーム - メインアプリケーション
 */

// ========================================
// 設定
// ========================================
const VERSION = '1.0.36';
const SESSION_ID = Math.random().toString(36).slice(2, 8);

const CONFIG = {
  spreadsheetId: '1eBk4OIyFRCGJYUgZ15bavQl5pngufGKUYm18Y0evJQg',
  rulesSheetId: '487776336',
  typewriterSpeed: 8, // 1-100
  // URLパラメータまたはリモート設定から取得
  startRule: parseInt(new URLSearchParams(window.location.search).get('startRule')) || 8,
  // GAS直接呼び出し（ステータス記録用）
  statusGasUrl: 'https://script.google.com/macros/s/AKfycbw2y_-q8WI8M4EwnNHWtH3ss73x2bMo6VlpdPiTMfY8RLfmbujNhZh16fudlHUnFms3TQ/exec',

  // ゲージ設定
  gaugeDuration: 54000,    // 0→90%の時間（ms）
  gaugePausePoint: 0.90,   // 停止ポイント（0-1）
  gaugePausePointVariance: 0.05, // 停止ポイントゆらぎ（±5%）
  gaugePauseDuration: 1000,      // 停止時間（ms）
  gaugePauseDurationVariance: 0.3, // 停止時間ゆらぎ（±30%）
  gaugeWaveAmplitude: 0.015, // ゆらぎの振幅（±1.5%）
  gaugeWaveFrequency: 0.3,   // 波の周波数（Hz）

  // タイポ設定
  typoChance: 0.05,        // タイポ確率（0-1）
  typoPause: 4,            // タイポ後の停止（倍率）

  // 切り替え停止（倍率）
  pauseNumToJa: 6,         // #番号 → 日本語
  pauseJaToEn: 7.5,        // 日本語 → 英語
  pauseEnToNum: 24,        // 英語 → 次の#番号（黒化後の間、100ms単位）

  // 句読点停止（倍率）
  pauseKuten: 9,           // 句点（。）
  pauseTouten: 7.5,        // 読点（、）
  pauseOpenBracket: 4,     // 開き括弧（「）
  pauseCloseBracket: 4,    // 閉じ括弧（」）
  pausePeriod: 6.5,        // ピリオド（.）
  pauseComma: 3,           // カンマ（,）
  pauseSpace: 0.5,         // スペース

  // ランダム幅
  varianceJa: 0.64,        // 日本語（±64%）
  varianceEn: 0.64,        // 英語（±64%）

  // 自動更新
  autoGenerateDelay: 180000, // 自動更新までの待ち時間（ms）= 3分、0で無効
};

// ========================================
// 状態管理
// ========================================
const state = {
  rules: [],
  segments: [],  // 「、」で分割されたセグメント
  currentSegmentIndex: 0,
  isGenerating: false,
  isThinking: false,  // 文字出力完了後、ゲージ待ち状態
  isPaused: false,  // リモートからの一時停止フラグ
  isAutoScroll: true,
  typewriterSpeed: CONFIG.typewriterSpeed,
  currentRuleElement: null,  // 現在表示中のルール要素
  currentJaElement: null,    // 現在表示中の日本語要素
  currentEnElement: null,    // 現在表示中の英語要素
  currentNumberElement: null, // 現在表示中の番号要素
  currentCaret: null,         // 画面上の唯一のキャレット

  // デバッグ用設定（リアルタイム変更可能）
  gaugeDuration: CONFIG.gaugeDuration,
  gaugePausePoint: CONFIG.gaugePausePoint,
  gaugePausePointVariance: CONFIG.gaugePausePointVariance,
  gaugePauseDuration: CONFIG.gaugePauseDuration,
  gaugePauseDurationVariance: CONFIG.gaugePauseDurationVariance,
  gaugeWaveAmplitude: CONFIG.gaugeWaveAmplitude,
  gaugeWaveFrequency: CONFIG.gaugeWaveFrequency,
  typoChance: CONFIG.typoChance,
  typoPause: CONFIG.typoPause,
  pauseNumToJa: CONFIG.pauseNumToJa,
  pauseJaToEn: CONFIG.pauseJaToEn,
  pauseEnToNum: CONFIG.pauseEnToNum,
  pauseKuten: CONFIG.pauseKuten,
  pauseTouten: CONFIG.pauseTouten,
  pauseOpenBracket: CONFIG.pauseOpenBracket,
  pauseCloseBracket: CONFIG.pauseCloseBracket,
  pausePeriod: CONFIG.pausePeriod,
  pauseComma: CONFIG.pauseComma,
  pauseSpace: CONFIG.pauseSpace,
  varianceJa: CONFIG.varianceJa,
  varianceEn: CONFIG.varianceEn,
  autoGenerateDelay: CONFIG.autoGenerateDelay,
};

// URLパラメータでデバッグモード判定（デフォルトでオン）
let isDebugMode = true;

// タイトル5回タップでデバッグモード
let titleTapCount = 0;
let titleTapTimer = null;

// ========================================
// DOM要素
// ========================================
const elements = {
  componentsJa: document.getElementById('components-ja'),
  componentsEn: document.getElementById('components-en'),
  handsJa: document.getElementById('hands-ja'),
  handsEn: document.getElementById('hands-en'),
  ruleList: document.getElementById('rule-list'),
  actionButton: document.getElementById('action-button'),
  actionButtonContainer: document.getElementById('action-button-container'),
  progressFill: document.getElementById('progress-fill'),
  scrollToBottom: document.getElementById('scroll-to-bottom'),
};

// ========================================
// Googleスプレッドシート データ取得
// ========================================
function getSheetUrl(sheetId, options = {}) {
  let url = `https://docs.google.com/spreadsheets/d/${CONFIG.spreadsheetId}/gviz/tq?tqx=out:json&gid=${sheetId}`;
  if (options.headers !== undefined) {
    url += `&headers=${options.headers}`;
  }
  return url;
}

function parseGoogleSheetResponse(text) {
  const jsonString = text.match(/google\.visualization\.Query\.setResponse\(([\s\S]*)\);?/);
  if (!jsonString) throw new Error('Invalid response format');
  return JSON.parse(jsonString[1]);
}

async function fetchSheetData(sheetId, options = {}) {
  const response = await fetch(getSheetUrl(sheetId, options));
  const text = await response.text();
  return parseGoogleSheetResponse(text);
}

// ========================================
// ルールの読み込みとセグメント化
// ========================================
async function loadRules() {
  try {
    const data = await fetchSheetData(CONFIG.rulesSheetId);
    const rows = data.table.rows;

    // config列を1行目から取得（config_startRule=L列, config_isPaused=M列）
    const remoteConfig = {};
    if (rows.length > 0 && rows[0].c) {
      const firstRow = rows[0].c;
      if (firstRow[11]?.v !== undefined && firstRow[11]?.v !== null) {
        remoteConfig.startRule = firstRow[11].v;
      }
      if (firstRow[12]?.v !== undefined && firstRow[12]?.v !== null) {
        remoteConfig.isPaused = firstRow[12].v;
      }
    }
    state.remoteConfig = remoteConfig;
    console.log('Remote config from rules sheet:', JSON.stringify(remoteConfig));

    state.rules = rows.map(row => {
      const cells = row.c;
      if (!cells) return null;

      return {
        num: cells[0]?.v || 0,           // A: num
        // cells[1] = major (skip)
        // cells[2] = ref (skip)
        ja: cells[3]?.v || '',            // D: ja
        en: cells[4]?.v || '',            // E: en
        // cells[5] = auto_translate (skip)
        jankenJa: cells[6]?.v || '',      // G: janken_ja
        jankenEn: cells[7]?.v || '',      // H: janken_en
        // cells[8] = auto_translate_janken_en (skip)
        componentJa: cells[9]?.v || '',   // J: component_ja
        componentEn: cells[10]?.v || '',  // K: component_en
      };
    }).filter(rule => rule && rule.ja);

    // キャッシュに保存
    localStorage.setItem('cachedRules', JSON.stringify({ version: VERSION, data: state.rules }));

    // セグメント化（「、」で分割）
    state.segments = prepareSegments(state.rules);

    console.log(`Loaded ${state.rules.length} rules, ${state.segments.length} segments`);
  } catch (error) {
    console.error('Failed to load rules:', error);
    reportStatus('エラー');
    // キャッシュから復帰を試みる
    const rawCached = localStorage.getItem('cachedRules');
    if (rawCached) {
      const cached = JSON.parse(rawCached);
      // バージョン付きキャッシュか旧形式かを判定
      if (cached?.version === VERSION && cached.data) {
        console.log('Loading rules from versioned cache');
        state.rules = cached.data;
      } else if (Array.isArray(cached)) {
        console.log('Loading rules from legacy cache (clearing)');
        localStorage.removeItem('cachedRules');
        return;  // 旧キャッシュは使わない
      } else {
        console.log('Cache version mismatch, clearing');
        localStorage.removeItem('cachedRules');
        return;
      }
      state.segments = prepareSegments(state.rules);
      console.log(`Loaded ${state.rules.length} rules from cache`);
    }
  }
}

function prepareSegments(rules) {
  const segments = [];
  rules.forEach(rule => {
    // 「、」の後ろで分割（「、」を含む）
    const jaParts = rule.ja.split(/(?<=、)/);

    jaParts.forEach((part, i) => {
      segments.push({
        num: rule.num,
        jaSegment: part,
        enFull: i === jaParts.length - 1 ? rule.en : null,  // 最後のセグメントのみ英語
        isFirst: i === 0,  // このルールの最初のセグメントか
        isLast: i === jaParts.length - 1,  // このルールの最後のセグメントか
        // 最初のセグメントにのみ内容物・じゃんけん情報を付与
        componentJa: i === 0 ? rule.componentJa : '',
        componentEn: i === 0 ? rule.componentEn : '',
        jankenJa: i === 0 ? rule.jankenJa : '',
        jankenEn: i === 0 ? rule.jankenEn : '',
      });
    });
  });
  return segments;
}

// ========================================
// 左パネル：内容物・じゃんけんの手
// ========================================
let componentCount = 0;  // 表示済み内容物の数
let handsCount = 0;      // 表示済みじゃんけんの手の数
let leftPanelQueue = Promise.resolve();  // 左パネルタイプライターのキュー

// 即時表示（初期表示用）
function addComponentInstant(ja, en) {
  if (componentCount > 0) {
    elements.componentsJa.appendChild(document.createTextNode(' / '));
    elements.componentsEn.appendChild(document.createTextNode(' / '));
  }
  elements.componentsJa.appendChild(document.createTextNode(ja));
  elements.componentsEn.appendChild(document.createTextNode(en));
  componentCount++;
}

function addHandInstant(ja, en) {
  if (handsCount > 0) {
    elements.handsJa.appendChild(document.createElement('br'));
    elements.handsEn.appendChild(document.createElement('br'));
  }
  elements.handsJa.appendChild(document.createTextNode(ja));
  elements.handsEn.appendChild(document.createTextNode(en));
  handsCount++;
}

// タイプライター表示（生成中用、キューで逐次実行）
function queueLeftPanelTypewriter(type, ja, en) {
  leftPanelQueue = leftPanelQueue.then(() => typewriterLeftPanel(type, ja, en));
}

async function typewriterLeftPanel(type, ja, en) {
  const isComponent = type === 'component';
  const jaEl = isComponent ? elements.componentsJa : elements.handsJa;
  const enEl = isComponent ? elements.componentsEn : elements.handsEn;
  const count = isComponent ? componentCount : handsCount;

  // 区切りを追加
  if (count > 0) {
    if (isComponent) {
      jaEl.appendChild(document.createTextNode(' / '));
      enEl.appendChild(document.createTextNode(' / '));
    } else {
      jaEl.appendChild(document.createElement('br'));
      enEl.appendChild(document.createElement('br'));
    }
  }

  // 日本語をタイプライター表示
  for (const char of ja) {
    jaEl.appendChild(document.createTextNode(char));
    await delay(getTypewriterDelay(char));
  }

  // 英語をタイプライター表示
  for (const char of en) {
    enEl.appendChild(document.createTextNode(char));
    await delay(getTypewriterDelayEn(char));
  }

  if (isComponent) {
    componentCount++;
  } else {
    handsCount++;
  }
}

// ========================================
// タイプライター表示
// ========================================
class Typewriter {
  constructor(element, options = {}) {
    this.element = element;
    this.onProgress = options.onProgress || (() => {});
    this.onComplete = options.onComplete || (() => {});
    this.isRunning = false;
    this.caret = null;
  }

  getDelay() {
    const normalized = state.typewriterSpeed / 100;
    const delay = 200 * Math.pow(0.05, normalized);
    return Math.max(10, Math.min(200, delay));
  }

  createCaret(isGenerating = false) {
    const caret = document.createElement('span');
    caret.className = 'caret';
    if (isGenerating) {
      caret.classList.add('generating');
    }
    return caret;
  }

  async type(text, options = {}) {
    const { generating = false } = options;
    this.isRunning = true;
    this.caret = this.createCaret(generating);

    const totalChars = text.length;

    for (let i = 0; i < text.length; i++) {
      if (!this.isRunning) break;

      const char = text[i];
      const textNode = document.createTextNode(char);

      if (this.caret.parentNode) {
        this.caret.parentNode.insertBefore(textNode, this.caret);
      } else {
        this.element.appendChild(textNode);
        this.element.appendChild(this.caret);
      }

      // 進捗コールバック
      this.onProgress((i + 1) / totalChars);

      if (state.isAutoScroll) {
        scrollToBottom();
      }

      await this.delay(this.getDelay());
    }

    this.isRunning = false;
    this.onComplete();
    return this.caret;  // キャレットを返す（思考状態用）
  }

  removeCaret() {
    if (this.caret && this.caret.parentNode) {
      this.caret.remove();
    }
    this.caret = null;
  }

  async think(duration = 1000) {
    if (this.caret) {
      this.caret.classList.add('thinking');
      await this.delay(duration);
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  stop() {
    this.isRunning = false;
  }
}

// ========================================
// ルール表示
// ========================================
function createRuleElement(num) {
  const ruleElement = document.createElement('div');
  ruleElement.className = 'rule-item';

  const numberElement = document.createElement('span');
  numberElement.className = 'rule-number generating';
  // 番号は空で作成（後でタイプライター表示）
  numberElement.textContent = '';
  numberElement.dataset.num = num;  // 番号を保存

  const contentElement = document.createElement('div');
  contentElement.className = 'rule-content';

  const jaElement = document.createElement('p');
  jaElement.className = 'rule-ja generating';

  const enElement = document.createElement('p');
  enElement.className = 'rule-en generating';

  contentElement.appendChild(jaElement);
  contentElement.appendChild(enElement);

  ruleElement.appendChild(numberElement);
  ruleElement.appendChild(contentElement);

  elements.ruleList.appendChild(ruleElement);

  return { ruleElement, numberElement, jaElement, enElement };
}

function makeCurrentRuleBlack() {
  if (state.currentNumberElement) {
    state.currentNumberElement.classList.remove('generating');
  }
  if (state.currentJaElement) {
    state.currentJaElement.classList.remove('generating');
  }
  if (state.currentEnElement) {
    state.currentEnElement.classList.remove('generating');
  }
}

// ========================================
// ページタイトル更新（リモート監視用）
// ========================================
function updatePageTitle() {
  const currentSegment = state.segments[state.currentSegmentIndex - 1];
  const currentRuleNum = currentSegment ? currentSegment.num : CONFIG.startRule;

  let status = '待機中';
  if (state.isPaused) {
    status = '停止中';
  } else if (state.isGenerating) {
    status = '更新中';
  }

  document.title = `#${currentRuleNum} ${status}`;
}

// ========================================
// ステータス送信（GAS直接呼び出しでスプレッドシートに記録）
// ========================================
let lastReportedStatus = null;

function reportStatus(status) {
  if (!CONFIG.statusGasUrl) return;

  const currentSegment = state.segments[state.currentSegmentIndex - 1];
  const num = currentSegment ? currentSegment.num : CONFIG.startRule;
  const segment = `${state.currentSegmentIndex}/${state.segments.length}`;

  // 同じステータスなら送信しない
  const statusKey = `${num}-${status}`;
  if (statusKey === lastReportedStatus) return;
  lastReportedStatus = statusKey;

  // パラメータ組み立て
  const params = new URLSearchParams({
    timestamp: new Date().toISOString(),
    sessionId: SESSION_ID,
    num: num,
    segment: segment,
    status: status,
  });

  // リロード時のみuserAgent付与
  if (status === 'リロード') {
    params.set('userAgent', navigator.userAgent);
  }

  const url = `${CONFIG.statusGasUrl}?${params.toString()}`;

  fetch(url, { mode: 'no-cors' })
    .then(() => console.log(`Status: ${status} #${num} (${segment})`))
    .catch(e => console.error('Status report failed:', e));
}

// ========================================
// キャレット制御
// ========================================
function showThinkingCaret() {
  removeCurrentCaret();
  const caret = document.createElement('span');
  caret.className = 'caret thinking generating';
  if (state.currentJaElement) {
    state.currentJaElement.appendChild(caret);
  }
  state.currentCaret = caret;
}

function removeCurrentCaret() {
  if (state.currentCaret && state.currentCaret.parentNode) {
    state.currentCaret.remove();
  }
  state.currentCaret = null;
}

function transformCaretToBar() {
  if (state.currentCaret) {
    state.currentCaret.classList.remove('thinking');
  }
}

function transformCaretToThinking() {
  if (state.currentCaret) {
    state.currentCaret.classList.add('thinking');
  }
}

// ========================================
// 初期表示（#1〜#8 + #9の最初のブレークポイント）
// ========================================
function findSegmentIndexForRule(ruleNum, position) {
  // 指定ルール番号の最初/最後のセグメントインデックスを返す
  let firstIndex = -1;
  let lastIndex = -1;

  for (let i = 0; i < state.segments.length; i++) {
    if (Number(state.segments[i].num) === Number(ruleNum)) {
      if (firstIndex === -1) firstIndex = i;
      lastIndex = i;
    }
  }

  return position === 'first' ? firstIndex : lastIndex;
}

function findNextBreakpointIndex(startIndex) {
  // 指定インデックスから次のブレークポイント（「、」で終わるセグメント）を探す
  for (let i = startIndex; i < state.segments.length; i++) {
    if (state.segments[i].jaSegment.endsWith('、')) {
      return i;
    }
  }
  return state.segments.length - 1; // 見つからなければ最後まで
}

function displayInitialRules() {
  // 開始ルール番号を取得（URLパラメータまたはリモート設定）
  const startRule = CONFIG.startRule;

  // 開始ルールの最後のセグメントを取得
  const ruleEnd = findSegmentIndexForRule(startRule, 'last');

  if (ruleEnd === -1) {
    console.warn(`Rule #${startRule} not found in ${state.segments.length} segments, starting from beginning`);
    // フォールバック：先頭のブレークポイントまで表示
    if (state.segments.length === 0) return;
  }

  // 次のルールの最初のブレークポイントまで表示
  const initialEndIndex = ruleEnd === -1
    ? findNextBreakpointIndex(0)
    : findNextBreakpointIndex(ruleEnd + 1);

  for (let i = 0; i <= initialEndIndex; i++) {
    const segment = state.segments[i];

    // 新しいルール番号なら要素を作成
    if (segment.isFirst) {
      const { numberElement, jaElement, enElement } = createRuleElement(segment.num);
      state.currentNumberElement = numberElement;
      state.currentJaElement = jaElement;
      state.currentEnElement = enElement;

      // 初期表示なので番号を即座に設定
      numberElement.textContent = `#${segment.num}`;

      // 開始ルール以下は黒、それ以降はグレー
      if (Number(segment.num) <= Number(startRule)) {
        numberElement.classList.remove('generating');
        jaElement.classList.remove('generating');
        enElement.classList.remove('generating');
      }

      // 内容物・じゃんけんの手を即時表示
      if (segment.componentJa) {
        addComponentInstant(segment.componentJa, segment.componentEn);
      }
      if (segment.jankenJa) {
        addHandInstant(segment.jankenJa, segment.jankenEn);
      }
    }

    // 日本語テキストを追加（タイプライターなし）
    const textNode = document.createTextNode(segment.jaSegment);
    state.currentJaElement.appendChild(textNode);

    // ルールの最後なら英語も表示
    if (segment.isLast && segment.enFull) {
      state.currentEnElement.textContent = segment.enFull;
      // 英語表示後、ルールを黒に
      state.currentNumberElement.classList.remove('generating');
      state.currentJaElement.classList.remove('generating');
    }
  }

  // 次のセグメントインデックスを設定
  state.currentSegmentIndex = initialEndIndex + 1;

  // 最後のセグメントにキャレットを表示
  showThinkingCaret();

  // スクロール位置を最下部に
  setTimeout(() => {
    scrollToBottom();
  }, 100);

  // ページタイトル更新
  updatePageTitle();

  console.log(`Initial display complete. Next segment index: ${state.currentSegmentIndex}`);
}

// ========================================
// ブレークポイント生成
// ========================================

// 次のブレークポイントまで生成するセグメントを計算
function calculateSegmentsToGenerate() {
  const segments = [];
  let totalChars = 0;
  let i = state.currentSegmentIndex;
  let foundBreakpointInNextRule = false;

  while (i < state.segments.length && !foundBreakpointInNextRule) {
    const seg = state.segments[i];
    segments.push({ ...seg, index: i });
    totalChars += seg.jaSegment.length;

    if (seg.isLast && seg.enFull) {
      totalChars += seg.enFull.length;
    }

    // 次のルールのブレークポイントで停止
    if (seg.isLast) {
      // 現在のルールが終了、次のルールへ
      i++;
      while (i < state.segments.length) {
        const nextSeg = state.segments[i];
        segments.push({ ...nextSeg, index: i });
        totalChars += nextSeg.jaSegment.length;

        if (nextSeg.jaSegment.endsWith('、')) {
          foundBreakpointInNextRule = true;
          break;
        }

        if (nextSeg.isLast && nextSeg.enFull) {
          totalChars += nextSeg.enFull.length;
        }
        i++;
      }
      break;
    }
    i++;
  }

  return { segments, totalChars };
}

// メイン生成関数：次のブレークポイントまで生成
// trigger: 'manual'（ボタン）, 'auto'（タイマー）
async function generateUntilNextBreakpoint(trigger = 'manual') {
  clearAutoGenerateTimer();
  if (state.isGenerating || state.isThinking) return;
  if (state.isPaused) {
    console.log('Generation paused by remote config');
    return;
  }
  if (state.currentSegmentIndex >= state.segments.length) {
    console.log('No more segments to display');
    return;
  }

  // トリガー種別をログ送信
  reportStatus(trigger === 'auto' ? '自動更新' : '手動更新');

  state.isGenerating = true;
  state.isThinking = false;
  updateButtonState();
  updatePageTitle();

  // ボタン押下時に最下部へスクロール＆自動スクロール有効化
  state.isAutoScroll = true;
  scrollToBottom();

  // 生成するセグメントと総文字数を計算
  const { segments: segmentsToGenerate, totalChars } = calculateSegmentsToGenerate();
  console.log(`Total chars: ${totalChars}`);

  // ゲージタイマー開始（1分で0→100%）
  startGaugeTimer();

  // ●キャレットを｜に変化
  transformCaretToBar();

  let charsDone = 0;

  for (const seg of segmentsToGenerate) {
    // 新しいルール番号なら要素を作成
    if (seg.isFirst) {
      const { ruleElement, numberElement, jaElement, enElement } = createRuleElement(seg.num);
      state.currentRuleElement = ruleElement;
      state.currentNumberElement = numberElement;
      state.currentJaElement = jaElement;
      state.currentEnElement = enElement;
      // 新規ルールの場合はキャレットも新規作成
      removeCurrentCaret();
      // 新しいルール要素が見えるようにスクロール
      if (state.isAutoScroll) {
        scrollToBottom();
      }
      // 番号をタイプライター表示
      await typewriterNumber(seg.num);

      // 内容物・じゃんけんの手をタイプライター表示（右パネルと並行）
      if (seg.componentJa) {
        queueLeftPanelTypewriter('component', seg.componentJa, seg.componentEn);
      }
      if (seg.jankenJa) {
        queueLeftPanelTypewriter('hands', seg.jankenJa, seg.jankenEn);
      }
    }

    // 日本語タイプライター（統合進捗）
    await typewriterJaWithProgress(seg.jaSegment, charsDone, totalChars, seg.isFirst);
    charsDone += seg.jaSegment.length;

    // ルールの最後なら英語をタイプライター表示
    if (seg.isLast && seg.enFull) {
      removeCurrentCaret();
      await typewriterEnWithProgress(seg.enFull, charsDone, totalChars);
      charsDone += seg.enFull.length;
      // じわっと黒にフェード
      makeCurrentRuleBlack();
      // アニメーション完了を待つ（英語→次の番号への間）
      await delay(state.pauseEnToNum * 100);
    }

    state.currentSegmentIndex++;
  }

  // 最後のセグメントが「、」で終わるなら●に変化
  const lastSeg = segmentsToGenerate[segmentsToGenerate.length - 1];
  if (lastSeg && lastSeg.jaSegment.endsWith('、')) {
    transformCaretToThinking();
  }

  // 文字出力完了を通知（ゲージがまだなら思考中状態へ）
  onTextComplete();

  if (state.isAutoScroll) {
    scrollToBottom();
  }
}

// 日本語タイプライター（統合進捗付き）
async function typewriterJaWithProgress(text, baseChars, totalChars, isNewRule = false) {
  // キャレットがなければ作成
  if (!state.currentCaret) {
    const caret = document.createElement('span');
    caret.className = 'caret generating';
    state.currentJaElement.appendChild(caret);
    state.currentCaret = caret;
  }

  // 番号 → 日本語の切り替え待機
  if (isNewRule) {
    await delay(getTypewriterDelay() * state.pauseNumToJa);
  }

  for (let i = 0; i < text.length; i++) {
    const char = text[i];

    // たまにタイポ（確率設定可能、句読点や括弧では発生しない）
    const isPunctuation = '。、．，「」『』（）()'.includes(char);
    if (!isPunctuation && Math.random() < state.typoChance) {
      // 間違った文字を入力
      const typoChar = getRandomTypoChar();
      const typoNode = document.createTextNode(typoChar);
      if (state.currentCaret && state.currentCaret.parentNode) {
        state.currentCaret.parentNode.insertBefore(typoNode, state.currentCaret);
      }
      if (state.isAutoScroll) scrollToBottom();
      await delay(getTypewriterDelay() * 0.8);

      // 一瞬止まる（気づく）
      await delay(getTypewriterDelay() * state.typoPause);

      // バックスペース（削除）
      if (typoNode.parentNode) {
        typoNode.remove();
      }
      if (state.isAutoScroll) scrollToBottom();
      await delay(getTypewriterDelay() * 0.5);
    }

    const textNode = document.createTextNode(char);

    // キャレットの前にテキストを挿入
    if (state.currentCaret && state.currentCaret.parentNode) {
      state.currentCaret.parentNode.insertBefore(textNode, state.currentCaret);
    } else {
      state.currentJaElement.appendChild(textNode);
    }

    // 統合進捗更新
    const progress = (baseChars + i + 1) / totalChars;
    updateProgressBar(progress);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    // 文字に応じた遅延
    await delay(getTypewriterDelay(char));
  }
}

// ランダムなタイポ文字を返す
function getRandomTypoChar() {
  const typoChars = 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん';
  return typoChars[Math.floor(Math.random() * typoChars.length)];
}

// 番号タイプライター（#nn）
async function typewriterNumber(num) {
  const text = `#${num}`;
  const caret = document.createElement('span');
  caret.className = 'caret generating';
  state.currentNumberElement.appendChild(caret);
  state.currentCaret = caret;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const textNode = document.createTextNode(char);
    caret.parentNode.insertBefore(textNode, caret);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    await delay(getTypewriterDelay());
  }

  // キャレットを削除（日本語タイプライターで新しく作る）
  caret.remove();
  state.currentCaret = null;
}

// 英語タイプライター（統合進捗付き）
async function typewriterEnWithProgress(text, baseChars, totalChars) {
  // 日本語 → 英語の切り替え待機
  await delay(getTypewriterDelay() * state.pauseJaToEn);

  const caret = document.createElement('span');
  caret.className = 'caret';
  state.currentEnElement.appendChild(caret);

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const textNode = document.createTextNode(char);
    caret.parentNode.insertBefore(textNode, caret);

    // 統合進捗更新
    const progress = (baseChars + i + 1) / totalChars;
    updateProgressBar(progress);

    if (state.isAutoScroll) {
      scrollToBottom();
    }

    // 文字に応じた遅延（英語用）
    await delay(getTypewriterDelayEn(char));
  }

  // 英語タイプライター終了後、キャレットを削除
  caret.remove();
}

// タイプライター速度計算（日本語用）
// 自然なゆらぎのある速度（1分縛りなし）
function getTypewriterDelay(char = '') {
  // 速度1: 約200ms, 速度100: 約10ms
  const speed = state.typewriterSpeed;
  const base = 200 * Math.pow(0.05, (speed - 1) / 99);

  // 句読点で少し考える時間を追加
  if (char === '。' || char === '．') {
    return base * state.pauseKuten;
  }
  if (char === '、' || char === '，') {
    return base * state.pauseTouten;
  }
  if (char === '「' || char === '『' || char === '(' || char === '（') {
    return base * state.pauseOpenBracket;
  }
  if (char === '」' || char === '』' || char === ')' || char === '）') {
    return base * state.pauseCloseBracket;
  }

  // ランダム性を加える
  const randomFactor = 1 + (Math.random() - 0.5) * state.varianceJa * 2;
  return base * randomFactor;
}

// タイプライター速度計算（英語用）
// 日本語と同じ速度計算を使用
function getTypewriterDelayEn(char = '') {
  const speed = state.typewriterSpeed;
  const base = 200 * Math.pow(0.05, (speed - 1) / 99);

  // 英語の句読点
  if (char === '.') {
    return base * state.pausePeriod;
  }
  if (char === ',') {
    return base * state.pauseComma;
  }
  if (char === ' ') {
    return base * state.pauseSpace;
  }

  // ランダム性を加える
  const randomFactor = 1 + (Math.random() - 0.5) * state.varianceEn * 2;
  return base * randomFactor;
}

// ディレイユーティリティ
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// ========================================
// 進捗バー（時間基準：54秒で0→90%、残り10%で文字完了待ち）
// ========================================
let gaugeStartTime = null;
let gaugeAnimationFrame = null;
let textComplete = false;  // 文字出力が完了したか
let gaugePausedAt90 = false;  // 90%で一時停止中か
let currentPausePoint = 0.90;  // 今回の停止ポイント（ゆらぎ適用後）
let autoGenerateTimer = null;  // 自動更新タイマー

function startGaugeTimer() {
  gaugeStartTime = Date.now();
  textComplete = false;
  gaugePausedAt90 = false;
  lastGaugeProgress = 0;  // ゆらぎ用進捗をリセット

  // 停止ポイントにゆらぎを適用（毎回違う位置で止まる）
  const variance = (Math.random() * 2 - 1) * state.gaugePausePointVariance;
  currentPausePoint = Math.max(0.5, Math.min(0.99, state.gaugePausePoint + variance));

  animateGauge();
}

let lastGaugeProgress = 0;  // 前回の進捗を記憶（戻らないように）

function animateGauge() {
  if (!gaugeStartTime) return;

  const elapsed = Date.now() - gaugeStartTime;

  // 呼吸のような波で速度を変調（0〜1の範囲、負にならない）
  const wave = Math.sin(elapsed * state.gaugeWaveFrequency * 0.001 * Math.PI * 2);
  const speedMultiplier = 1 + wave * state.gaugeWaveAmplitude * 10;  // 0.85〜1.15程度
  const effectiveSpeed = Math.max(0, speedMultiplier);  // 負にならないように

  // 基本進捗に速度変調を適用（積分的に進む）
  const deltaTime = 16;  // 約60fps
  const progressIncrement = (deltaTime / state.gaugeDuration) * effectiveSpeed;
  let progress = Math.min(lastGaugeProgress + progressIncrement, currentPausePoint);

  // 進捗は常に増加のみ（戻らない）
  progress = Math.max(lastGaugeProgress, progress);
  lastGaugeProgress = progress;

  elements.progressFill.style.width = `${progress * 100}%`;

  if (progress < currentPausePoint) {
    // まだ停止ポイントに達していない
    gaugeAnimationFrame = requestAnimationFrame(animateGauge);
  } else {
    // 停止ポイントに達した
    if (textComplete) {
      // 文字も終わってる → 即座に100%へ
      finishGauge();
    } else {
      // 文字がまだ → 停止ポイントで一時停止（onTextCompleteで再開）
      gaugePausedAt90 = true;
    }
  }
}

function finishGauge() {
  // 停止時間にゆらぎを適用
  const durationVariance = (Math.random() * 2 - 1) * state.gaugePauseDurationVariance;
  const pauseDuration = Math.max(100, state.gaugePauseDuration * (1 + durationVariance));

  // 停止後 → 100% へスムーズにアニメーション
  setTimeout(() => {
    elements.progressFill.style.transition = 'width 0.5s ease-out';
    elements.progressFill.style.width = '100%';

    setTimeout(() => {
      elements.progressFill.style.transition = '';
      onGaugeComplete();
    }, 500);
  }, pauseDuration);
}

function onGaugeComplete() {
  gaugeAnimationFrame = null;
  gaugeStartTime = null;
  gaugePausedAt90 = false;

  // 思考中状態を解除
  state.isThinking = false;
  state.isGenerating = false;
  updateButtonState();
  updatePageTitle();
  reportStatus('待機中');

  // 自動更新タイマー開始
  startAutoGenerateTimer();
}

// ========================================
// 自動更新タイマー
// ========================================
function startAutoGenerateTimer() {
  clearAutoGenerateTimer();
  if (state.autoGenerateDelay <= 0) return;  // 0以下なら無効
  autoGenerateTimer = setTimeout(() => {
    if (!state.isGenerating && !state.isThinking && !state.isPaused) {
      generateUntilNextBreakpoint('auto');
    }
  }, state.autoGenerateDelay);
}

function clearAutoGenerateTimer() {
  if (autoGenerateTimer) {
    clearTimeout(autoGenerateTimer);
    autoGenerateTimer = null;
  }
}

function onTextComplete() {
  textComplete = true;

  if (gaugePausedAt90) {
    // ゲージが90%で待っていた → 100%へ
    finishGauge();
  } else if (gaugeStartTime) {
    // ゲージがまだ動いている → 思考中状態へ
    state.isThinking = true;
    updateButtonState();
  }
  // ゲージが既に完了済み（gaugeStartTime === null）なら何もしない
}

function resetProgressBar() {
  if (gaugeAnimationFrame) {
    cancelAnimationFrame(gaugeAnimationFrame);
    gaugeAnimationFrame = null;
  }
  gaugeStartTime = null;
  textComplete = false;
  gaugePausedAt90 = false;
  lastGaugeProgress = 0;  // ゆらぎ用進捗もリセット
  elements.progressFill.style.transition = '';
  elements.progressFill.style.width = '0%';
}

// 旧APIとの互換性（呼び出し箇所では何もしない）
function updateProgressBar(progress) {
  // 文字進捗は無視（ゲージは時間基準）
}

// ========================================
// ボタン状態
// ========================================
function updateButtonState() {
  const button = elements.actionButton;
  const container = elements.actionButtonContainer;
  const buttonJa = button.querySelector('.button-ja');
  const buttonEn = button.querySelector('.button-en');

  if (state.isThinking) {
    // 思考中（文字出力完了、ゲージ待ち）
    button.classList.add('generating');
    container.classList.add('generating');
    container.classList.remove('idle');
    buttonJa.textContent = '次のルールを思考中...';
    buttonEn.textContent = 'Thinking...';
  } else if (state.isGenerating) {
    // 生成中（文字出力中）
    button.classList.add('generating');
    container.classList.add('generating');
    container.classList.remove('idle');
    buttonJa.textContent = 'ルール生成中...';
    buttonEn.textContent = 'Generating Rules...';
  } else {
    // 待機中
    button.classList.remove('generating');
    container.classList.remove('generating');
    container.classList.add('idle');
    buttonJa.textContent = '続きを生成';
    buttonEn.textContent = 'Continue Generating';
    resetProgressBar();
  }

  if (state.currentSegmentIndex >= state.segments.length) {
    button.disabled = true;
  }
}

// ========================================
// スクロール制御
// ========================================
function scrollToBottom() {
  elements.ruleList.scrollTo({
    top: elements.ruleList.scrollHeight,
    behavior: 'smooth',
  });
}

function checkScrollPosition() {
  const list = elements.ruleList;
  const isAtBottom = list.scrollHeight - list.scrollTop - list.clientHeight < 50;

  state.isAutoScroll = isAtBottom;

  if (isAtBottom) {
    elements.scrollToBottom.classList.remove('visible');
  } else {
    elements.scrollToBottom.classList.add('visible');
  }
}

// ========================================
// イベントリスナー
// ========================================
function setupEventListeners() {
  // ボタンコンテナ全体をクリック可能に
  elements.actionButtonContainer.addEventListener('click', generateUntilNextBreakpoint);

  // 展示用：コンテキストメニュー無効化
  document.addEventListener('contextmenu', (e) => e.preventDefault());

  elements.ruleList.addEventListener('scroll', checkScrollPosition);

  elements.scrollToBottom.addEventListener('click', () => {
    state.isAutoScroll = true;
    scrollToBottom();
    elements.scrollToBottom.classList.remove('visible');
  });

  // タイトル5回タップでデバッグモード有効化
  const gameTitle = document.querySelector('.game-title');
  if (gameTitle) {
    gameTitle.addEventListener('click', () => {
      titleTapCount++;

      // タイマーリセット（2秒以内に5回タップ）
      if (titleTapTimer) clearTimeout(titleTapTimer);
      titleTapTimer = setTimeout(() => {
        titleTapCount = 0;
      }, 2000);

      // 5回タップでデバッグモード有効化
      if (titleTapCount >= 5) {
        titleTapCount = 0;
        if (!isDebugMode) {
          isDebugMode = true;
          setupDebugPanel();
        }
      }
    });
  }
}

// ========================================
// 開発用：速度調整
// ========================================
window.setTypewriterSpeed = function(speed) {
  state.typewriterSpeed = Math.max(1, Math.min(100, speed));
  console.log(`Typewriter speed set to: ${state.typewriterSpeed}`);
};

window.getTypewriterSpeed = function() {
  return state.typewriterSpeed;
};

// デバッグ用
window.getState = function() {
  return state;
};

// ========================================
// リモート設定（ルールシートのconfig列から取得）
// ========================================
function startRemoteConfigPolling() {
  // 1分ごとにルールシートからリモート設定を確認
  setInterval(async () => {
    try {
      const data = await fetchSheetData(CONFIG.rulesSheetId);
      const rows = data.table.rows;
      if (!rows || rows.length === 0) return;

      const firstRow = rows[0].c;
      if (!firstRow) return;

      const config = {};
      if (firstRow[11]?.v !== undefined && firstRow[11]?.v !== null) {
        config.startRule = firstRow[11].v;
      }
      if (firstRow[12]?.v !== undefined && firstRow[12]?.v !== null) {
        config.isPaused = firstRow[12].v;
      }
      state.remoteConfig = config;

      // 一時停止フラグの確認
      const isPaused = config.isPaused === true || config.isPaused === 'true' || config.isPaused === 'TRUE';
      if (isPaused && !state.isPaused) {
        console.log('Remote pause activated');
        state.isPaused = true;
        state.isGenerating = false;
        updatePageTitle();
        reportStatus('停止中');
      } else if (!isPaused && state.isPaused) {
        console.log('Remote pause deactivated');
        state.isPaused = false;
        updatePageTitle();
        reportStatus('待機中');
      }

      // 開始ルール番号の確認（次回リロード時に反映）
      if (config.startRule !== undefined) {
        const newStartRule = parseInt(config.startRule);
        if (!isNaN(newStartRule) && newStartRule !== CONFIG.startRule) {
          console.log(`Start rule updated: ${CONFIG.startRule} -> ${newStartRule}`);
          // URLパラメータがない場合のみリモート設定を使用
          if (!new URLSearchParams(window.location.search).has('startRule')) {
            CONFIG.startRule = newStartRule;
          }
        }
      }
    } catch (e) {
      console.error('Remote config polling failed:', e);
    }
  }, 60000); // 1分間隔
}

// ========================================
// デバッグパネル
// ========================================

// エクスポート可能な設定キー
const EXPORTABLE_KEYS = [
  'typewriterSpeed',
  'gaugeDuration',
  'gaugePausePoint',
  'gaugePausePointVariance',
  'gaugePauseDuration',
  'gaugePauseDurationVariance',
  'gaugeWaveAmplitude',
  'gaugeWaveFrequency',
  'autoGenerateDelay',
  'typoChance',
  'typoPause',
  'pauseNumToJa',
  'pauseJaToEn',
  'pauseEnToNum',
  'pauseKuten',
  'pauseTouten',
  'pauseOpenBracket',
  'pauseCloseBracket',
  'pausePeriod',
  'pauseComma',
  'pauseSpace',
  'varianceJa',
  'varianceEn',
];

// 設定をテキストにエクスポート
function exportSettings() {
  const settings = {};
  EXPORTABLE_KEYS.forEach(key => {
    settings[key] = state[key];
  });
  return JSON.stringify(settings, null, 2);
}

// テキストから設定をインポート
function importSettings(text) {
  try {
    const settings = JSON.parse(text);
    EXPORTABLE_KEYS.forEach(key => {
      if (settings[key] !== undefined) {
        state[key] = settings[key];
      }
    });
    // スライダーUIを更新
    refreshSliders();
    return true;
  } catch (e) {
    console.error('Import failed:', e);
    return false;
  }
}

// すべてのスライダーを現在のstate値で更新
function refreshSliders() {
  // setupSliderで登録した設定を再度反映
  const sliderConfigs = [
    { slider: 'speed-slider', value: 'speed-value', key: 'typewriterSpeed', scale: 1, toFixed: null },
    { slider: 'gauge-duration-slider', value: 'gauge-duration-value', key: 'gaugeDuration', scale: 1000, toFixed: null },
    { slider: 'gauge-pause-slider', value: 'gauge-pause-value', key: 'gaugePausePoint', scale: 0.01, toFixed: null },
    { slider: 'typo-chance-slider', value: 'typo-chance-value', key: 'typoChance', scale: 0.01, toFixed: null },
    { slider: 'typo-pause-slider', value: 'typo-pause-value', key: 'typoPause', scale: 1, toFixed: 1 },
    { slider: 'pause-num-ja-slider', value: 'pause-num-ja-value', key: 'pauseNumToJa', scale: 1, toFixed: 1 },
    { slider: 'pause-ja-en-slider', value: 'pause-ja-en-value', key: 'pauseJaToEn', scale: 1, toFixed: 1 },
    { slider: 'pause-en-num-slider', value: 'pause-en-num-value', key: 'pauseEnToNum', scale: 1, toFixed: null },
    { slider: 'pause-kuten-slider', value: 'pause-kuten-value', key: 'pauseKuten', scale: 1, toFixed: 1 },
    { slider: 'pause-touten-slider', value: 'pause-touten-value', key: 'pauseTouten', scale: 1, toFixed: 1 },
    { slider: 'pause-open-bracket-slider', value: 'pause-open-bracket-value', key: 'pauseOpenBracket', scale: 1, toFixed: 1 },
    { slider: 'pause-bracket-slider', value: 'pause-bracket-value', key: 'pauseCloseBracket', scale: 1, toFixed: 1 },
    { slider: 'pause-period-slider', value: 'pause-period-value', key: 'pausePeriod', scale: 1, toFixed: 1 },
    { slider: 'pause-comma-slider', value: 'pause-comma-value', key: 'pauseComma', scale: 1, toFixed: 1 },
    { slider: 'pause-space-slider', value: 'pause-space-value', key: 'pauseSpace', scale: 1, toFixed: 1 },
    { slider: 'variance-ja-slider', value: 'variance-ja-value', key: 'varianceJa', scale: 0.01, toFixed: null },
    { slider: 'variance-en-slider', value: 'variance-en-value', key: 'varianceEn', scale: 0.01, toFixed: null },
  ];

  sliderConfigs.forEach(({ slider, value, key, scale, toFixed }) => {
    const sliderEl = document.getElementById(slider);
    const valueEl = document.getElementById(value);
    if (sliderEl && valueEl) {
      const displayValue = state[key] / scale;
      sliderEl.value = displayValue;
      valueEl.textContent = toFixed !== null ? displayValue.toFixed(toFixed) : displayValue;
    }
  });
}

// スライダー設定ヘルパー
function setupSlider(sliderId, valueId, stateKey, options = {}) {
  const { scale = 1, suffix = '', toFixed = null } = options;
  const slider = document.getElementById(sliderId);
  const valueEl = document.getElementById(valueId);
  if (!slider || !valueEl) return;

  // 初期値を設定
  const currentValue = state[stateKey] / scale;
  slider.value = currentValue;
  valueEl.textContent = toFixed !== null ? currentValue.toFixed(toFixed) : currentValue;

  // 入力時に更新
  slider.addEventListener('input', (e) => {
    const rawValue = parseFloat(e.target.value);
    state[stateKey] = rawValue * scale;
    valueEl.textContent = toFixed !== null ? rawValue.toFixed(toFixed) : rawValue;
  });
}

function setupDebugPanel() {
  if (!isDebugMode) return;

  const panel = document.getElementById('debug-panel');
  const resetBtn = document.getElementById('debug-reset');
  const closeBtn = document.getElementById('debug-close');
  const cacheClearBtn = document.getElementById('debug-cache-clear');

  if (!panel) return;

  panel.hidden = false;

  // バージョン表示
  const versionEl = document.getElementById('debug-version');
  if (versionEl) versionEl.textContent = VERSION;

  // 基本設定
  setupSlider('speed-slider', 'speed-value', 'typewriterSpeed');
  setupSlider('auto-generate-slider', 'auto-generate-value', 'autoGenerateDelay', { scale: 1000 });

  // ゲージ設定
  setupSlider('gauge-duration-slider', 'gauge-duration-value', 'gaugeDuration', { scale: 1000 });
  setupSlider('gauge-pause-slider', 'gauge-pause-value', 'gaugePausePoint', { scale: 0.01 });
  setupSlider('gauge-pause-variance-slider', 'gauge-pause-variance-value', 'gaugePausePointVariance', { scale: 0.01 });
  setupSlider('gauge-pause-duration-slider', 'gauge-pause-duration-value', 'gaugePauseDuration', { scale: 100 });
  setupSlider('gauge-pause-duration-variance-slider', 'gauge-pause-duration-variance-value', 'gaugePauseDurationVariance', { scale: 0.01 });
  setupSlider('gauge-wave-amp-slider', 'gauge-wave-amp-value', 'gaugeWaveAmplitude', { scale: 0.001, toFixed: 1 });
  setupSlider('gauge-wave-freq-slider', 'gauge-wave-freq-value', 'gaugeWaveFrequency', { scale: 0.1, toFixed: 1 });

  // タイポ設定
  setupSlider('typo-chance-slider', 'typo-chance-value', 'typoChance', { scale: 0.01 });
  setupSlider('typo-pause-slider', 'typo-pause-value', 'typoPause', { toFixed: 1 });

  // 切り替え停止
  setupSlider('pause-num-ja-slider', 'pause-num-ja-value', 'pauseNumToJa', { toFixed: 1 });
  setupSlider('pause-ja-en-slider', 'pause-ja-en-value', 'pauseJaToEn', { toFixed: 1 });
  setupSlider('pause-en-num-slider', 'pause-en-num-value', 'pauseEnToNum');

  // 句読点停止
  setupSlider('pause-kuten-slider', 'pause-kuten-value', 'pauseKuten', { toFixed: 1 });
  setupSlider('pause-touten-slider', 'pause-touten-value', 'pauseTouten', { toFixed: 1 });
  setupSlider('pause-open-bracket-slider', 'pause-open-bracket-value', 'pauseOpenBracket', { toFixed: 1 });
  setupSlider('pause-bracket-slider', 'pause-bracket-value', 'pauseCloseBracket', { toFixed: 1 });
  setupSlider('pause-period-slider', 'pause-period-value', 'pausePeriod', { toFixed: 1 });
  setupSlider('pause-comma-slider', 'pause-comma-value', 'pauseComma', { toFixed: 1 });
  setupSlider('pause-space-slider', 'pause-space-value', 'pauseSpace', { toFixed: 1 });

  // ランダム幅
  setupSlider('variance-ja-slider', 'variance-ja-value', 'varianceJa', { scale: 0.01 });
  setupSlider('variance-en-slider', 'variance-en-value', 'varianceEn', { scale: 0.01 });

  // リセットボタン（シンプルにリロード）
  resetBtn.addEventListener('click', () => {
    location.reload();
  });

  // 閉じるボタン（パネルを非表示にするだけ）
  closeBtn.addEventListener('click', () => {
    panel.hidden = true;
    isDebugMode = false;
  });

  // キャッシュクリア＆リロードボタン
  cacheClearBtn.addEventListener('click', async () => {
    // Service Worker のキャッシュをクリア
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
    }
    // Service Worker を登録解除
    if ('serviceWorker' in navigator) {
      const registrations = await navigator.serviceWorker.getRegistrations();
      await Promise.all(registrations.map(reg => reg.unregister()));
    }
    // 強制リロード
    location.reload(true);
  });

  // エクスポートボタン
  const exportBtn = document.getElementById('debug-export');
  const exportArea = document.getElementById('debug-export-area');
  if (exportBtn && exportArea) {
    exportBtn.addEventListener('click', () => {
      exportArea.value = exportSettings();
      exportArea.style.display = 'block';
      exportArea.select();
    });
  }

  // インポートボタン
  const importBtn = document.getElementById('debug-import');
  if (importBtn && exportArea) {
    importBtn.addEventListener('click', () => {
      if (exportArea.style.display === 'none') {
        exportArea.style.display = 'block';
        exportArea.value = '';
        exportArea.placeholder = 'Paste JSON here...';
        exportArea.focus();
      } else if (exportArea.value.trim()) {
        if (importSettings(exportArea.value)) {
          exportArea.style.display = 'none';
          exportArea.value = '';
        } else {
          alert('Invalid JSON format');
        }
      }
    });
  }

  // 定期的に状態表示を更新
  setInterval(() => {
    const segmentEl = document.getElementById('debug-segment');
    const totalEl = document.getElementById('debug-total');
    const statusEl = document.getElementById('debug-status');

    if (segmentEl) segmentEl.textContent = state.currentSegmentIndex;
    if (totalEl) totalEl.textContent = state.segments.length;
    if (statusEl) {
      if (state.isPaused) {
        statusEl.textContent = '停止中';
      } else if (state.isThinking) {
        statusEl.textContent = '思考中';
      } else if (state.isGenerating) {
        statusEl.textContent = '生成中';
      } else {
        statusEl.textContent = '待機中';
      }
    }
  }, 500);

  // デバッグパネルのドラッグ機能
  const header = document.querySelector('.debug-header');
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  const startDrag = (clientX, clientY) => {
    isDragging = true;
    const rect = panel.getBoundingClientRect();
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    panel.style.transition = 'none';
  };

  const doDrag = (clientX, clientY) => {
    if (!isDragging) return;
    const x = clientX - dragOffsetX;
    const y = clientY - dragOffsetY;
    panel.style.left = `${Math.max(0, x)}px`;
    panel.style.top = `${Math.max(0, y)}px`;
    panel.style.bottom = 'auto';
    panel.style.right = 'auto';
  };

  const endDrag = () => {
    isDragging = false;
    panel.style.transition = '';
  };

  // マウスイベント
  header.addEventListener('mousedown', (e) => {
    startDrag(e.clientX, e.clientY);
  });
  document.addEventListener('mousemove', (e) => {
    doDrag(e.clientX, e.clientY);
  });
  document.addEventListener('mouseup', endDrag);

  // タッチイベント（iPad用）
  header.addEventListener('touchstart', (e) => {
    const touch = e.touches[0];
    startDrag(touch.clientX, touch.clientY);
  }, { passive: true });
  document.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    const touch = e.touches[0];
    doDrag(touch.clientX, touch.clientY);
  }, { passive: true });
  document.addEventListener('touchend', endDrag);
}

// ========================================
// 初期化
// ========================================
async function init() {
  console.log('Initializing app...');

  setupEventListeners();

  // ルールを読み込み（ルールシートにconfig列も含む）
  await loadRules();
  console.log(`Rules loaded: ${state.rules.length}, Segments: ${state.segments.length}`);

  // リモート設定を適用（URLパラメータがない場合）
  if (!new URLSearchParams(window.location.search).has('startRule')) {
    if (state.remoteConfig?.startRule !== undefined) {
      const startRule = parseInt(state.remoteConfig.startRule);
      if (!isNaN(startRule)) {
        CONFIG.startRule = startRule;
        console.log(`Start rule from remote config: ${startRule}`);
      }
    }
  }
  console.log(`CONFIG.startRule = ${CONFIG.startRule}`);

  // 初期ルールを表示
  displayInitialRules();

  // 初回の自動更新タイマー開始
  startAutoGenerateTimer();

  // デバッグパネルをセットアップ
  setupDebugPanel();

  // リモート設定の定期確認を開始
  startRemoteConfigPolling();

  // リロードログ送信
  reportStatus('リロード');

  console.log('App initialized');
}

document.addEventListener('DOMContentLoaded', init);
